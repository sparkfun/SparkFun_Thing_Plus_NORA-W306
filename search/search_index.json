{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Placeholder file for index redirect functionality.</p>"},{"location":"arduino_example_10_ws2812/","title":"Example 10 - WS2812 Addressable RGB LED","text":"<p>In this example, we will blink the WS2812.</p>"},{"location":"arduino_example_10_ws2812/#hardware-hookup","title":"Hardware Hookup","text":"<p>The connection is the same as explained earlier in the tutorial. Connect the USB cable to the SparkFun Thing Plus NORA-W306 and the other end to your computer. For the scope of this tutorial, we will be using the built-in WS2812B on the development board.</p> <p>For those that are interested in connecting additional WS2812, you can follow the table below to daisy chain additional LEDs. This configuration is when users are using USB for power and daisy chaining a small number of WS2812's.</p> NORA-W306Pinout              WS2812 LEDPinout              VUSB (if powering off USBand low number of WS2812 LEDs) VIN LD/LED_D0 DI GND GND <p>For large number of LEDs, you may want to considering using an external power supply to power the strip of addressable LEDs.</p> NORA-W306Pinout              External 5V Power Supply              WS2812 LEDPinout              5V VIN LD/LED_D0 DI GND GND GND"},{"location":"arduino_example_10_ws2812/#arduino-code","title":"Arduino Code","text":"<p>Let's upload the sketch control the WS2812. We recommend using the WS2812B Arduino Library that came installed with the board add-on. Below is a modified example of the WS2812B_Basics.ino sketch since we the LED is on the secondary SPI port and we are using new terminology for the macro. Of course, since we are using only one WS2812, we also adjusted the code to acknowledge that we have only controlling one LED. Copy and paste the following code in the Arduino IDE.</p> <p>Note</p> <p>This code is modified and not the same as the one in the board-add on!!! A few lines were commented out, a macro was used when making an instance of the WS2812B, one LED is used, and the red and green colors are blinking in the loop. For a comparison, you could view the original code provided in the board support package by heading to: File &gt; Examples &gt; File &gt; Examples &gt; Examples for SparkFun Thing Plus NORA-W306 (RTL8720DF) | AmebaWS2812B &gt; WS2812B_Basics.</p> <p>Copy and paste the following code in the Arduino IDE. Select the correct board definition from the menu (in this case, Tools &gt; Board &gt; Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz) &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF)). Then select the correct COM port that the board enumerated to (in this case, it was COM13). Hit upload button.  </p> <pre><code>/*\n\n Example guide:\n https://www.amebaiot.com/en/amebad-arduino-ws2812b-basics/\n */\n\n#include \"WS2812B.h\"\n\n#define TOTAL_NUM_OF_LED 1\n#define NUM_OF_LEDS 1\n\n// There are multiple choice of SPI_MOSI pins depends on different boards. The default is SPI_MOSI/SPI1_MOSI\n// AMB21/AMB22              pin 11 /  pin21\n// AMB23                    pin 9  /  pin 4\n// BW16/BW16 Type C         pin 12\n// AW-CU488 ThingPlus       pin 1  /  pin 14\n// AMB25/AMB26              pin 17 /  pin 3\n// NORA-W306 Thing Plus     pin 6  /  pin 14\n\n\n//WS2812B led(SPI_MOSI, TOTAL_NUM_OF_LED);  //default SPI macro\nWS2812B led(SPI1_PICO, TOTAL_NUM_OF_LED); // SPI1 macro for NORA-W306 since built-in WS2812 is attached to secondary SPI pin\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(\"WS2812B test\");\n    led.begin();\n    //Set a specific LED with a certain color\n    led.setPixelColor(0, 50, 0, 0);\n    //led.setPixelColor(1, 0, 50, 0);\n    //led.setPixelColor(2, 0, 0, 50);\n    led.show();\n    delay(1000);\n    //Fill the entire LED strip with the same color\n    //led.fill(60, 0, 25, 0, NUM_OF_LEDS);\n    //led.show();\n}\n\nvoid loop() {\n    led.setPixelColor(0, 50, 0, 0);\n    led.show();\n    delay(1000);\n\n    led.setPixelColor(0, 0, 50, 0);\n    led.show();\n    delay(1000);\n}\n</code></pre> <p>After uploading code, the built-in WS2812B LED will light up red momentarily. Once in the loop, the red and green LED will blink back and forth every second. Try adjusting the code to control the LED to make primary, secondary, or tertiary colors with the press of a button! Or changing the color of the LED based on how much power your LiPo battery has available. Or even modify the WS2812B_Patterns.ino included with the board add-on to add effects and patterns to your LED. You can even go as far as soldering additional WS2812Bs by daisy chaining them to the DO / LED_DO pin. Just make sure that you have a sufficient power supply to power your all of your LEDs.</p> WS2812 Addressable LED Green LED Turned On"},{"location":"arduino_example_11_qwiic_micro_oled/","title":"Example 11 - Qwiic Micro OLED","text":"<p>In this example, we will connect a Qwiic-enabled Micro OLED display.</p>"},{"location":"arduino_example_11_qwiic_micro_oled/#hardware-hookup","title":"Hardware Hookup","text":"<p>To connect the Qwiic Micro OLED, simply insert a Qwiic cable between the display and the SparkFun Thing Plus NORA-W306.</p> Qwiic Micro OLED Connected to SparkFun Thing Plus NORA-W306 <p>When ready, connect the board to your computer with the USB C cable.</p>"},{"location":"arduino_example_11_qwiic_micro_oled/#installing-the-arduino-library","title":"Installing the Arduino Library","text":"<p>Note</p> <p>There are two SparkFun Arduino Libraries for the Qwiic micro OLED. We recommend using the SparkFun Qwiic OLED Arduino Library.</p> <p>If you have not already, make sure to install the following libraries as explained earlier.</p> <ul> <li>Qwiic OLED</li> </ul>"},{"location":"arduino_example_11_qwiic_micro_oled/#arduino-code","title":"Arduino Code","text":"<p>Let's upload the sketch to display graphics and characters on the Qwiic Micro OLED. From the menu, select the following: File &gt; Examples &gt; Examples from Custom Libraries | SparkFun OLED Graphics Library &gt; Example-01_Hello.</p> <p>Or you can copy and paste the following code in the Arduino IDE. Select the correct board definition from the menu (in this case, Tools &gt; Boards &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF)). Then select the correct COM port that the board enumerated to (in this case, it was COM13). Hit upload button.</p> <pre><code>/*\n\n  Example-01_Hello.ino\n\n  This demo shows the basic setup of the OLED library, generating simple graphics and displaying\n  the results on the target device.\n\n   Micro OLED             https://www.sparkfun.com/products/14532\n   Transparent OLED       https://www.sparkfun.com/products/15173\n   \"Narrow\" OLED          https://www.sparkfun.com/products/24606\n   Qwiic OLED 1.3in       https://www.sparkfun.com/products/23453\n\n  Written by Kirk Benell @ SparkFun Electronics, March 2022\n\n  Repository:\n     https://github.com/sparkfun/SparkFun_Qwiic_OLED_Arduino_Library\n\n  Documentation:\n     https://sparkfun.github.io/SparkFun_Qwiic_OLED_Arduino_Library/\n\n  SparkFun code, firmware, and software is released under the MIT License(http://opensource.org/licenses/MIT).\n*/\n\n#include &lt;SparkFun_Qwiic_OLED.h&gt; //http://librarymanager/All#SparkFun_Qwiic_OLED\n\n// The Library supports four different types of SparkFun boards. The demo uses the following\n// defines to determine which device is being used. Uncomment the device being used for this demo.\n\nQwiicMicroOLED myOLED;\n//QwiicTransparentOLED myOLED;\n//QwiicNarrowOLED myOLED;\n//Qwiic1in3OLED myOLED;\n\n\nvoid setup()\n{\n    Serial.begin(115200);\n    Serial.println(\"Running OLED example\");\n\n    Wire.begin();\n\n    // Initalize the OLED device and related graphics system\n    if (myOLED.begin() == false)\n    {\n        Serial.println(\"Device begin failed. Freezing...\");\n        while (true)\n            ;\n    }\n    Serial.println(\"Begin success\");\n\n    // Do a simple test - fill a rectangle on the screen and then print hello!\n\n    // Fill a rectangle on the screen that has a 4 pixel board\n    myOLED.rectangleFill(4, 4, myOLED.getWidth() - 8, myOLED.getHeight() - 8);\n\n    String hello = \"hello\"; // our message\n\n    // Center our message on the screen. Get the screen size of the \"hello\" string,\n    // calling the getStringWidth() and getStringHeight() methods on the oled\n\n    // starting x position - screen width minus string width  / 2\n    int x0 = (myOLED.getWidth() - myOLED.getStringWidth(hello)) / 2;\n\n    // starting y position - screen height minus string height / 2\n    int y0 = (myOLED.getHeight() - myOLED.getStringHeight(hello)) / 2;\n\n    // Draw the text - color of black (0)\n    myOLED.text(x0, y0, hello, 0);\n\n    // There's nothing on the screen yet - Now send the graphics to the device\n    myOLED.display();\n\n    // That's it - HELLO!\n}\n\nvoid loop()\n{\n    delay(1000); // Do nothing\n}\n</code></pre> <p>Once the code has been uploaded, check the Qwiic Micro OLED screen. You should see the entire screen filled with a rectangle with the \"hello\" in the middle. Try exploring the other examples in the folder and writing your own code to output on the screen.</p> Qwiic Micro OLED Connected to SparkFun Thing Plus NORA-W306 and with the Word \"hello\" Displayed"},{"location":"arduino_example_12_lipo_fuel_gauge_micro_oled_ws2812/","title":"Example 12 - MAX17048 LiPo Fuel Gauge with Micro OLED Display Demo","text":"<p>Based on the examples from the LiPo Fuel Gauge and Micro OLED, we will measure a battery's capacity and display the readings on a micro OLED.</p>"},{"location":"arduino_example_12_lipo_fuel_gauge_micro_oled_ws2812/#hardware-hookup","title":"Hardware Hookup","text":"<p>Connect the Qwiic micro OLED and LiPo battery to the board.</p> Fritzing Diagram Qwiic micro OLED and LiPo Battery <p>When ready, connect the board to your computer with the USB C cable.</p>"},{"location":"arduino_example_12_lipo_fuel_gauge_micro_oled_ws2812/#installing-the-arduino-libraries","title":"Installing the Arduino Libraries","text":"<p>If you have not already, make sure to install the following libraries as explained in the previous sections. As for the WS2812, we will be using the built-in Realtek Arduino library for the WS2812.</p> <ul> <li>MAX17048</li> <li>Qwiic OLED</li> </ul>"},{"location":"arduino_example_12_lipo_fuel_gauge_micro_oled_ws2812/#arduino-code","title":"Arduino Code","text":"<p>Copy and paste the following code in the Arduino IDE.</p> <pre><code>/******************************************************************************\n  Combined Simple Serial, Qwiic Micro OLED, WS2812 Example\n  Modified By: Ho Yun \"Bobby\" Chan\n  SparkFun Electronics\n  Date: July 10, 2024\n  License: MIT. See license file for more information but you can\n  basically do whatever you want with this code.\n\n  This is a combined example of Paul Clark's MAX17043 Fuel Guage\n  simple serial example, Kirk Benell's Qwiic OLED Hello example,\n  and Nathan Seidle's RTK Display Test Sketch. The example reads a\n  single cell LiPo battery's voltage and state-of-charge (SOC)\n  using the MAX1704X. The voltage, percent remaining (i.e. the\n  SOC), and alert flag are displayed as an output on the Qwiic\n  Micro OLED. A graphic of a LiPo battery's remaining charge is\n  displayed on the Qwiic Micro OLED as well. This example also uses\n  the built-in WS2812-2020 addressable LED to indicate the status\n  of the battery.\n\n  By opening the Arduino Serial Monitor (115200 baud), the example\n  will also print the gauge's voltage, state-of-charge (SOC)\n  readings, alert status to Serial.\n\n  Feel like supporting open source hardware?\n  Buy a board from SparkFun!\n\n  LiPo Fuel Gauge - MAX17043 : https://www.sparkfun.com/products/20680\n  Qwiic Micro OLED: https://www.sparkfun.com/products/14532\n\n  Distributed as-is; no warranty is given.\n******************************************************************************/\n\n#include &lt;Wire.h&gt; // Needed for I2C\n\n\n//////////LIPO FUEL GAUGE//////////\n#include &lt;SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library.h&gt; // Click here to get the library: http://librarymanager/All#SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library\n\n//SFE_MAX1704X lipo; // Defaults to the MAX17043\n\n//SFE_MAX1704X lipo(MAX1704X_MAX17043); // Create a MAX17043\n//SFE_MAX1704X lipo(MAX1704X_MAX17044); // Create a MAX17044\nSFE_MAX1704X lipo(MAX1704X_MAX17048); // Create a MAX17048\n//SFE_MAX1704X lipo(MAX1704X_MAX17049); // Create a MAX17049\n\ndouble voltage = 0; // Variable to keep track of LiPo voltage\ndouble soc = 0; // Variable to keep track of LiPo state-of-charge (SOC)\nbool alert; // Variable to keep track of whether alert has been triggered\n\n\n\n//////////QWIIC MICRO OLED//////////\n#include &lt;SparkFun_Qwiic_OLED.h&gt; //http://librarymanager/All#SparkFun_Qwiic_Graphic_OLED\n#include \"icons.h\"\n\n// The Qwiic OLED Library supports three different types of SparkFun boards. The demo uses the following\n// defines to determine which device is being used. Uncomment the device being used for this demo.\nQwiicMicroOLED myOLED;\n// QwiicTransparentOLED myOLED;\n// QwiicNarrowOLED myOLED;\n\n// Fonts\n#include &lt;res/qw_fnt_5x7.h&gt;\n//#include &lt;res/qw_fnt_8x16.h&gt;, not used\n//#include &lt;res/qw_fnt_31x48.h&gt;, not used\n//#include &lt;res/qw_fnt_7segment.h&gt;, not used\n//#include &lt;res/qw_fnt_largenum.h&gt;, not used\n\n\n// NOTE: This example uses the Realtek Arduino Core's WS2812 Library\n//////////WS2812 LED//////////\n#include \"WS2812B.h\"\n\n#define TOTAL_NUM_OF_LED 1\n#define NUM_OF_LEDS 1\n\n// There are multiple choice of SPI_MOSI pins depends on different boards. The default is SPI_MOSI/SPI1_MOSI\n// AMB21/AMB22              pin 11 /  pin21\n// AMB23                    pin 9  /  pin 4\n// BW16/BW16 Type C         pin 12\n// AW-CU488 ThingPlus       pin 1  /  pin 14\n// AMB25/AMB26              pin 17 /  pin 3\n\nWS2812B led(SPI1_PICO, NUM_OF_LEDS);\n\nvoid setup() {\n  Serial.begin(115200); // Start serial, to output debug data\n  //while (!Serial)\n  //  ; //Wait for user to open terminal\n  Serial.println(F(\"Combined MAX17048, Qwiic OLED, and Realtek WS2812 Example\"));\n\n  Wire.begin();\n\n  lipo.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial\n\n  // Set up the MAX17043 LiPo fuel gauge:\n  if (lipo.begin() == false) // Connect to the MAX17043 using the default wire port\n  {\n    Serial.println(F(\"MAX17043 not detected. Please check wiring. Freezing.\"));\n    while (1)\n      ;\n  }\n\n  // Initalize the OLED device and related graphics system\n  if (myOLED.begin() == false)\n  {\n    Serial.println(F(\"Device begin failed. Freezing...\"));\n    while (true)\n      ;\n  }\n\n  // Quick start restarts the MAX17043 in hopes of getting a more accurate\n  // guess for the SOC.\n  lipo.quickStart();\n\n  // We can set an interrupt to alert when the battery SoC gets too low.\n  // We can alert at anywhere between 1% - 32%:\n  lipo.setThreshold(20); // Set alert threshold to 20%.\n\n  //Set up WS2812B\n  led.begin();\n  //led.setPixelColor(led_position, red, green, blue);...\n  //led.setPixelColor(0, 0, 0, 0);\n  //led.show();\n  delay(1000);\n\n}\n\nvoid loop() {\n\n  // lipo.getVoltage() returns a voltage value (e.g. 3.93)\n  voltage = lipo.getVoltage();\n\n  // lipo.getSOC() returns the estimated state of charge (e.g. 79%)\n  soc = lipo.getSOC();\n\n  // lipo.getAlert() clears the alert flag\n  // Output: 0 on success, positive integer on fail.\n  lipo.clearAlert();\n  // lipo.getAlert() returns a 0 or 1 (0=alert not triggered)\n  alert = lipo.getAlert();\n\n  myOLED.erase(); //clear display\n\n  //set font type, we'll use a character size of 5x7\n  myOLED.setFont(&amp;QW_FONT_5X7);\n  //myOLED.setFont(&amp;QW_FONT_8X16); //not used\n  //myOLED.setFont(&amp;QW_FONT_31X48); //not used\n  //myOLED.setFont(&amp;QW_FONT_LARGENUM); //not used\n  //myOLED.setFont(&amp;QW_FONT_7SEGMENT); //not used\n\n  // \"Print\" Voltage\n  myOLED.setCursor(0, 0);\n  myOLED.print(voltage, 2);\n  myOLED.print(F(\"V\"));\n\n  // \"Print\" Battery %\n  myOLED.setCursor(0, 10);\n  myOLED.print(soc, 2);\n  myOLED.print(F(\"%\"));\n\n  // \"Print\" Alert Status\n  myOLED.setCursor(0, 20);\n  myOLED.print(F(\"VBAT:\")); //alert pin\n  if (alert == HIGH) {\n    myOLED.print(F(\"LOW\")); //Flag was raised, battery is low!!!\n  }\n  else {\n\n    myOLED.print(F(\"OK\")); //Battery charge is good. 8)\n  }\n\n  if (soc &gt;= 60.00) {\n    //Battery Level 60-100%\n    displayBitmap(0, 30, Battery_2_Width, Battery_2_Height, Battery_3);\n\n    //GREEN\n    led.setPixelColor(0, 0, 50, 0);\n    led.show();\n\n  }\n  else if (30.00 &lt;= soc &lt; 60.00) {\n    //Battery Level 30-60%\n    displayBitmap(0, 30, Battery_2_Width, Battery_2_Height, Battery_2);\n\n    //YELLOW\n    led.setPixelColor(0, 50, 50, 0);\n    led.show();\n  }\n  else if (10.00 &lt;= soc &lt; 30.00) {\n    //Battery Level 10%-30%\n    displayBitmap(0, 30, Battery_2_Width, Battery_2_Height, Battery_1);\n\n    //ORANGE\n    led.setPixelColor(0, 50, 25, 0);\n    led.show();\n  }\n  else {\n    //Battery Level &lt;10%\n    displayBitmap(0, 30, Battery_2_Width, Battery_2_Height, Battery_0);\n\n    //RED\n    led.setPixelColor(0, 50, 0, 0);\n    led.show();\n  }\n\n\n  // There's nothing on the screen yet - Now send the graphics to the device\n  myOLED.display();\n\n\n  // Print the variables to Serial Terminal:\n  Serial.print(F(\"Voltage: \"));\n  Serial.print(voltage);  // Print the battery voltage\n  Serial.println(\" V\");\n\n  Serial.print(F(\"Percentage: \"));\n  Serial.print(soc); // Print the battery state of charge\n  Serial.println(\" %\");\n\n  Serial.print(F(\"Alert: \"));\n  Serial.println(alert);\n  Serial.println();\n\n  delay(500);\n}\n\n\n\n//Wrapper to avoid needing to pass width/height data twice\nvoid displayBitmap(uint8_t x, uint8_t y, uint8_t imageWidth, uint8_t imageHeight, uint8_t *imageData) {\n  myOLED.bitmap(x, y, x + imageWidth, y + imageHeight, imageData, imageWidth, imageHeight);\n}\n</code></pre> <p>To keep track of the icons that we create, we are going to create a header file with the *.ino. This is useful when writing code for big projects that involve a lot of components. Click on the icon to create a new tab. We will name this icons.h.</p>  New Tab <p>Copy and paste the following code into tab.</p> <pre><code>uint8_t Battery_3 [] = {\n0xFF, 0x01, 0xFD, 0xFD, 0xFD, 0x01, 0x01, 0xFD, 0xFD, 0xFD, 0x01, 0x01, 0xFD, 0xFD, 0xFD, 0x01,\n0x0F, 0x08, 0xF8, 0x0F, 0x08, 0x0B, 0x0B, 0x0B, 0x08, 0x08, 0x0B, 0x0B, 0x0B, 0x08, 0x08, 0x0B,\n0x0B, 0x0B, 0x08, 0x0F, 0x01, 0x01,\n};\nint Battery_3_Height = 12;\nint Battery_3_Width = 19;\n\nuint8_t Battery_2 [] = {\n0xFF, 0x01, 0xFD, 0xFD, 0xFD, 0x01, 0x01, 0xFD, 0xFD, 0xFD, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n0x0F, 0x08, 0xF8, 0x0F, 0x08, 0x0B, 0x0B, 0x0B, 0x08, 0x08, 0x0B, 0x0B, 0x0B, 0x08, 0x08, 0x08,\n0x08, 0x08, 0x08, 0x0F, 0x01, 0x01,\n};\nint Battery_2_Height = 12;\nint Battery_2_Width = 19;\n\nuint8_t Battery_1 [] = {\n0xFF, 0x01, 0xFD, 0xFD, 0xFD, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n0x0F, 0x08, 0xF8, 0x0F, 0x08, 0x0B, 0x0B, 0x0B, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n0x08, 0x08, 0x08, 0x0F, 0x01, 0x01,\n};\nint Battery_1_Height = 12;\nint Battery_1_Width = 19;\n\nuint8_t Battery_0 [] = {\n0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n0x0F, 0x08, 0xF8, 0x0F, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n0x08, 0x08, 0x08, 0x0F, 0x01, 0x01,\n};\nint Battery_0_Height = 12;\nint Battery_0_Width = 19;\n</code></pre> <p>If you have not already, select your Board (in this case the SparkFun Thing Plus NORA-W306 (RTL8720DF)), and associated COM port (in this case COM13). Then hit the upload button. Disconnect the USB cable from the SparkFun Thing Plus NORA-W306 and hit the reset button on the board.</p> <p>Looking close at the display, you should see the voltage, remaining charge, the alert flag indicating if the battery is low, and a battery meter icon. These values may be different depending on how much charge the LiPo battery has available! The RGB LED color will also change to the following colors based as well: green (battery level &gt; 60%), yellow (battery level 30%-60%), orange (battery level 10%-30%), and red (battery level &lt;10%).</p> LiPo Fuel Gauge Monitoring LiPo Battery and Displaying Battery Capacity on Qwiic Micro OLED"},{"location":"arduino_example_1_blink/","title":"Example 1 - Blink","text":"<p>Now that we have our board add-on installed, we can get started playing around with the development board. For the scope of this tutorial, we will highlight a few of the features on the board. From there we will be able to build our own custom code to integrate the development board into a project.</p> <p>In this example, we will blink the LED that is built into the SparkFun Thing Plus NORA-W306.</p>"},{"location":"arduino_example_1_blink/#hardware-hookup","title":"Hardware Hookup","text":"<p>The connection is the same as explained earlier in the tutorial. Connect the USB cable to the SparkFun Thing Plus NORA-W306. Of course, make sure to connect the other end to your computer.</p> USB Cable inserted into Thing Plus NORA-W306"},{"location":"arduino_example_1_blink/#arduino-code","title":"Arduino Code","text":"<p>Let's upload a sketch to the board. This example is the basic Arduino blink example. Note that we specify pin <code>18</code> instead of using the macro called <code>LED_BUILTIN</code>.</p> <p>Copy and paste the following code in the Arduino IDE. Select the correct board definition from the menu (in this case, Tools &gt; Board &gt; Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz) &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF). Then select the correct COM port that the board enumerated to (in this case, it was COM13). Hit upload button.</p> <pre><code>/*\n  Blink\n  Turns on an LED on for one second, then off for one second, repeatedly.\n\n  This example code is in the public domain.\n */\n\n// Pin 18 has an LED connected on most Arduino boards.\n// give it a name:\nint led = 18; //LED is connected to pin 18 on the SparkFun Thing Plus NORA-W306\n\n//NOTE: You can also use LED_BUILTIN.\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // initialize the digital pin as an output.\n  pinMode(led, OUTPUT);\n}\n\n// the loop routine runs over and over again forever:\nvoid loop() {\n  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)\n  delay(1000);               // wait for a second\n  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW\n  delay(1000);               // wait for a second\n}\n</code></pre> <p>Note</p> <p>Note: You can also use the macro for the LED by using <code>LED_BUILTIN</code>. The code in the built-in Arduino examples will function the same as well!</p> <p>Once uploaded, check the LED labeled as 18 on the board. It should be blinking on and off every second! Sweet!</p> SparkFun Thing Plus NORA-W306 User LED On"},{"location":"arduino_example_2_button/","title":"Example 2 - Button","text":"<p>This example goes over how to use the built-in button with the internal pull-up resistors on the microcontroller. While we are at it, we will also use the built-in LED to visually see what is going on right on the board without the need to open the Arduino Serial Monitor.</p>"},{"location":"arduino_example_2_button/#hardware-hookup","title":"Hardware Hookup","text":"<p>Connect the USB cable to the SparkFun Thing Plus NORA-W306 and the other end to your computer's COM port.</p> USB Cable inserted into Thing Plus NORA-W306"},{"location":"arduino_example_2_button/#arduino-code","title":"Arduino Code","text":"<p>Let's upload the sketch to check if there is a button press. The following code is a modified example that was built into the Arduino IDE (File &gt; Examples &gt; 02.Digital &gt; Button ) since there are no pull-up resistors connected to the button and the LED is on a different I/O pin.</p> <p>You can also copy and paste the following code in the Arduino IDE. Select the correct board definition from the menu (in this case, Tools &gt; Board &gt; Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz) &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF)). Then select the correct COM port that the board enumerated to (in this case, it was COM13). Hit upload button.</p> <pre><code>/*\n  Button\n\n  Turns on and off a light emitting diode (LED) connected to digital pin 18,\n  when pressing a pushbutton attached to pin 2.\n\n  The circuit:\n  - Built-in LED attached from pin 18 to ground and current limiting resistor\n  - Built-in pushbutton attached to pin 2 from +5V\n\n\n\n  modified 2024\n  by Ho Yun \"Bobby\" Chan\n\n  created 2005\n  by DojoDave &lt;http://www.0j0.org&gt;\n  modified 30 Aug 2011\n  by Tom Igoe\n\n  This example code is in the public domain.\n\n  https://www.arduino.cc/en/Tutorial/BuiltInExamples/Button\n*/\n\n// constants won't change. They're used here to set pin numbers:\nconst int buttonPin = 2;  // the number of the pushbutton pin\nconst int ledPin = 18;    // the number of the LED pin\n\n// variables will change:\nint buttonState = 0;  // variable for reading the pushbutton status\n\nvoid setup() {\n  // initialize the LED pin as an output:\n  pinMode(ledPin, OUTPUT);\n  // initialize the pushbutton pin as an input pullup:\n  pinMode(buttonPin, INPUT_PULLUP);\n}\n\nvoid loop() {\n  // read the state of the pushbutton value:\n  buttonState = digitalRead(buttonPin);\n\n  // check if the pushbutton is pressed. If it is, the buttonState is HIGH:\n  if (buttonState == HIGH) {\n    // turn LED on:\n    digitalWrite(ledPin, HIGH);\n  } else {\n    // turn LED off:\n    digitalWrite(ledPin, LOW);\n  }\n}\n</code></pre> <p>Once uploaded, check the LED labeled as 18 on the board. Pressing down on the user button connected to pin 2 will light up the LED. Releasing the button, the LED will turn off.</p> SparkFun Thing Plus NORA-W306 Button Press with LED Turned On"},{"location":"arduino_example_3_scan_wifi/","title":"Example 3 - Scanning WiFi Networks","text":"<p>In this example, we will scan for WiFi networks in the area.</p>"},{"location":"arduino_example_3_scan_wifi/#hardware-hookup","title":"Hardware Hookup","text":"<p>The connection is the same as explained earlier in the tutorial. Connect the USB cable to the SparkFun Thing Plus NORA-W306. Of course, make sure to connect the other end to your computer. You will also need a wireless router capable of 2.4GHz and 5GHz.</p> USB Cable inserted into Thing Plus NORA-W306"},{"location":"arduino_example_3_scan_wifi/#arduino-code","title":"Arduino Code","text":"<p>Let's try to scan for some WiFi networks. You can find this example included after installing the board add-on. Head to File &gt; Examples &gt; Examples for SparkFun Thing Plus NORA-W306 (RTL8720DF) | WiFi &gt; ScanNetworks .</p> <p>You can also copy and paste the following code in the Arduino IDE. Select the correct board definition from the menu (in this case, Tools &gt; Board &gt; Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz) &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF)). Then select the correct COM port that the board enumerated to (in this case, it was COM13). Hit upload button.</p> <pre><code>/*\n This example prints MAC address, and\n scans for available Wifi networks.\n Every ten seconds, it scans again. It doesn't actually\n connect to any network, so no encryption scheme is specified.\n\n created 13 July 2010\n by dlf (Metodo2 srl)\n modified 21 Junn 2012\n by Tom Igoe and Jaymes Dec\n\n modified 08 May 2023\n by Realtek SG\n\n Example guide:\n https://www.amebaiot.com/en/amebad-arduino-scan-wifi/\n */\n\n#include &lt;WiFi.h&gt;\n\nint status = WL_IDLE_STATUS;    // Indicater of Wifi status\n\nvoid setup() {\n    //Initialize serial and wait for port to open:\n    Serial.begin(115200);\n    while (!Serial) {\n        ; // wait for serial port to connect. Needed for native USB port only\n    }\n\n    // check for WiFi status:\n    status = WiFi.status();\n    // Print WiFi MAC address:\n    printMacAddress();\n}\n\nvoid loop() {\n    // scan for existing networks:\n    Serial.println(\"Scanning available networks...\");\n    listNetworks();\n    delay(10000);\n}\n\nvoid printMacAddress() {\n    // print your MAC address:\n    byte mac[6];\n    WiFi.macAddress(mac);\n    Serial.print(\"MAC: \");\n    Serial.print(mac[0], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[1], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[2], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[3], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[4], HEX);\n    Serial.print(\":\");\n    Serial.println(mac[5], HEX);\n}\n\nvoid listNetworks() {\n    // scan for nearby networks:\n    Serial.println(\"** Scan Networks **\");\n    int numSsid = WiFi.scanNetworks();\n    if (numSsid == -1) {\n        Serial.println(\"Couldn't get a wifi connection\");\n        while (true);\n    }\n\n    // print the list of networks seen:\n    Serial.print(\"number of available networks:\");\n    Serial.println(numSsid);\n\n    // print the network number and name for each network found:\n    for (int thisNet = 0; thisNet &lt; numSsid; thisNet++) {\n        Serial.print(thisNet);\n        Serial.print(\") \");\n        Serial.print(WiFi.SSID(thisNet));\n        Serial.print(\"\\tSignal: \");\n        Serial.print(WiFi.RSSI(thisNet));\n        Serial.print(\" dBm\");\n        Serial.print(\"\\tEncryptionRaw: \");\n        printEncryptionTypeEx(WiFi.encryptionTypeEx(thisNet));\n        Serial.print(\"\\tEncryption: \");\n        printEncryptionType(WiFi.encryptionType(thisNet));\n    }\n}\n\nvoid printEncryptionTypeEx(uint32_t thisType) {\n    /*  Arduino wifi api use encryption type to mapping to security type.\n    *  This function demonstrate how to get more richful information of security type.\n    */\n    switch (thisType) {\n        case SECURITY_OPEN:\n            Serial.print(\"Open\");\n            break;\n        case SECURITY_WEP_PSK:\n            Serial.print(\"WEP\");\n            break;\n        case SECURITY_WPA_TKIP_PSK:\n            Serial.print(\"WPA TKIP\");\n            break;\n        case SECURITY_WPA_AES_PSK:\n            Serial.print(\"WPA AES\");\n            break;\n        case SECURITY_WPA2_AES_PSK:\n            Serial.print(\"WPA2 AES\");\n            break;\n        case SECURITY_WPA2_TKIP_PSK:\n            Serial.print(\"WPA2 TKIP\");\n            break;\n        case SECURITY_WPA2_MIXED_PSK:\n            Serial.print(\"WPA2 Mixed\");\n            break;\n        case SECURITY_WPA_WPA2_MIXED:\n            Serial.print(\"WPA/WPA2 AES\");\n            break;\n        case SECURITY_WPA3_AES_PSK:\n            Serial.print(\"WPA3 AES\");\n            break;\n        case SECURITY_WPA2_WPA3_MIXED:\n            Serial.print(\"WPA2/WPA3\");\n    }\n}\n\nvoid printEncryptionType(int thisType) {\n    // read the encryption type and print out the name:\n    switch (thisType) {\n        case ENC_TYPE_WEP:\n            Serial.println(\"WEP\");\n            break;\n        case ENC_TYPE_WPA:\n            Serial.println(\"WPA\");\n            break;\n        case ENC_TYPE_WPA2:\n            Serial.println(\"WPA2\");\n            break;\n        case ENC_TYPE_WPA3:\n            Serial.println(\"WPA3\");\n            break;\n        case ENC_TYPE_NONE:\n            Serial.println(\"None\");\n            break;\n        case ENC_TYPE_AUTO:\n            Serial.println(\"Auto\");\n            break;\n    }\n}\n</code></pre> <p>Open you Arduino Serial Monitor at 115200. The SparkFun Thing Plus NORA-W306 will begin scanning your area. Take note of the encryption type of the WiFi network that you are connecting to. In this case, I had set my home WiFi Router's 5GHz network name to \"SparkFun_Router_5GHz\" and it was using a WPA2 encryption (as highlighted in the Arduino Serial Monitor).</p> SparkFun Router 5GHz Highlighted Arduino Output"},{"location":"arduino_example_4_connect_wifi/","title":"Example 4 - Connecing to a WiFi Network","text":"<p>In this example, we will connect to a 5GHz WiFi network.</p>"},{"location":"arduino_example_4_connect_wifi/#hardware-hookup","title":"Hardware Hookup","text":"<p>The connection is the same as explained earlier in the tutorial. Connect the USB cable to the SparkFun Thing Plus NORA-W306 and the other end to your computer. Again, you will need a wireless router capable of 2.4GHz and 5GHz.</p> USB Cable inserted into Thing Plus NORA-W306"},{"location":"arduino_example_4_connect_wifi/#arduino-code","title":"Arduino Code","text":"<p>Let's upload the sketch to connect to the 5GHz network in your area. From the menu, select the following: File &gt; Examples &gt; File &gt; Examples &gt; Examples for SparkFun Thing Plus NORA-W306 (RTL8720DF) | WiFi &gt; ConnectWithWiFi &gt; ConnectWithWPA. Depending on your encryption, you may select a different example.</p> <p>Note</p> <p>Depending on your encryption, you may select a different Arduino sketch to connect to the WiFi. Based on the previous example, the connection used WPA so we selected the ConnectWithWPA.ino example.</p> <p>Or you can copy and paste the following code in the Arduino IDE.</p> <pre><code>/*\n This example connects to an unencrypted Wifi network.\n Then it prints the MAC address,\n the IP address obtained, and other network details.\n\n created 13 July 2010\n by dlf (Metodo2 srl)\n modified 31 May 2012\n by Tom Igoe\n\n modified 08 May 2023\n by Realtek SG\n\n Example guide:\n https://www.amebaiot.com/en/amebad-arduino-connect-wifi/\n */\n\n#include &lt;WiFi.h&gt;\n\n// Set if user wants to key in ssid/pwd manually during operation\n//#define MANUAL_INPUT\n\n#ifdef MANUAL_INPUT  // Initialise ssid string, pwd string, and serial_in object\n// Initialise strings\nString str_ssid, str_pass;\n#endif\n\n// If you are connecting to an iPhone WiFi hotspot, the default SSID uses Unicode (U+2019) Right Single Quotation Mark instead of ASCII apostrophe\n// Modify the \"Your Name\" section in the SSID below to connect to an iPhone using a default SSID style\n// char ssid[] = \"Your Name\\xE2\\x80\\x99s iPhone\";\n\n// UTF-8 encoding can also be used for SSID with emoji characters\n// Emoji characters can be converted into UTF-8 at https://mothereff.in/utf-8\n// char ssid[] = \"\\xe2\\x9c\\x8c\\xef\\xb8\\x8f Ameba \\xe2\\x9c\\x8c\\xef\\xb8\\x8f\";\n\nchar ssid[] = \"Network_SSID\";       // your network SSID (name)\nchar pass[] = \"Password\";           // your network password\nint status = WL_IDLE_STATUS;        // Indicater of Wifi status\n\nvoid setup() {\n    //Initialize serial and wait for port to open:\n    Serial.begin(115200);\n    while (!Serial) {\n        ; // wait for serial port to connect. Needed for native USB port only\n    }\n\n    // attempt to connect to Wifi network:\n    while (status != WL_CONNECTED) {\n#ifdef MANUAL_INPUT\n        Serial.println(\"Enter your ssid\");\n        while (Serial.available() == 0) {}\n            str_ssid = Serial.readString();\n            str_ssid.trim();\n            Serial.print(\"SSID entered: \");\n            Serial.println(str_ssid);\n\n        Serial.println(\"Enter your password\");\n        while (Serial.available() == 0) {}\n        str_pass = Serial.readString();\n        str_pass.trim();\n            if (str_pass.length() != 0) { // user has entered data\n                while (str_pass.length() &lt;8 ) { // to catch pwd&lt;8 exception\n                    Serial.println(\"Password cannot be less than 8 characters! Try again\");\n                    while (Serial.available() == 0) {}\n                    str_pass = Serial.readString();\n                    str_pass.trim();\n                }\n                    Serial.print(\"Password entered: \");\n                    Serial.println(str_pass);\n            }\n#endif\n        Serial.print(\"Attempting to connect to WPA SSID: \");\n\n#ifndef MANUAL_INPUT\n        Serial.println(ssid);\n        // Connect to WPA/WPA2 network:\n        status = WiFi.begin(ssid, pass);\n#else\n        char ssid_cust[str_ssid.length() + 1];\n        char pass_cust[str_pass.length() + 1];\n        strcpy(ssid_cust, str_ssid.c_str());\n        strcpy(pass_cust, str_pass.c_str());\n        Serial.println(str_ssid.c_str());\n        status = WiFi.begin(ssid_cust, pass_cust);\n        str_ssid = str_pass = \"\";\n#endif\n        // wait 10 seconds for connection:\n        delay(10000);\n    }\n\n    // you're connected now, so print out the data:\n    Serial.println();\n    Serial.print(\"You're connected to the network\");\n    printCurrentNet();\n    printWifiData();\n}\n\nvoid loop() {\n    // check the network connection once every 10 seconds:\n    delay(10000);\n    printCurrentNet();\n}\n\nvoid printWifiData() {\n    // print your WiFi IP address:\n    IPAddress ip = WiFi.localIP();\n    Serial.print(\"IP Address: \");\n    Serial.println(ip);\n    Serial.println(ip);\n\n    // print your MAC address:\n    byte mac[6];\n    WiFi.macAddress(mac);\n    Serial.print(\"MAC address: \");\n    Serial.print(mac[0], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[1], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[2], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[3], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[4], HEX);\n    Serial.print(\":\");\n    Serial.println(mac[5], HEX);\n}\n\nvoid printCurrentNet() {\n    // print the SSID of the network you're attached to:\n    Serial.print(\"SSID: \");\n    Serial.println(WiFi.SSID());\n\n    // print the MAC address of the router you're attached to:\n    byte bssid[6];\n    WiFi.BSSID(bssid);\n    Serial.print(\"BSSID: \");\n    Serial.print(bssid[5], HEX);\n    Serial.print(\":\");\n    Serial.print(bssid[4], HEX);\n    Serial.print(\":\");\n    Serial.print(bssid[3], HEX);\n    Serial.print(\":\");\n    Serial.print(bssid[2], HEX);\n    Serial.print(\":\");\n    Serial.print(bssid[1], HEX);\n    Serial.print(\":\");\n    Serial.println(bssid[0], HEX);\n\n    // print the received signal strength:\n    long rssi = WiFi.RSSI();\n    Serial.print(\"signal strength (RSSI):\");\n    Serial.println(rssi);\n\n    // print the encryption type:\n    byte encryption = WiFi.encryptionType();\n    Serial.print(\"Encryption Type:\");\n    Serial.println(encryption, HEX);\n    Serial.println();\n}\n</code></pre> <p>Then adjust the arrays that holed the SSID (i.e. <code>yourNetwork</code>) and password  (<code>secretPassword</code>) based on your WiFi network's settings.</p> SSID Changed <p>Select the correct board definition from the menu (in this case, Tools &gt; Boards &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF)). Then select the correct COM port that the board enumerated to (in this case, it was COM13). Hit upload button.</p> <p>Open the Arduino Serial Monitor at 115200. The SparkFun Thing Plus NORA-W306 will attempt to connect to the network.</p> Serial Monitor attempting to connect to WiFi network <p>If all goes well, you should see some status outputs and message indicating that you are connected to your network! In this case, I had the following message:</p> <pre>\n    <code>You're connected to the networkSSID: SparkFun_Router_5GHz</code>\n</pre> <p>The serial output will then continue outputting the status of the connection some of which include the SSID, signal strength (RSSI), and encryption type.  If you have admin privileges, you can check to see if the device is connected to the 5GHz WiFi network as well. Try connecting to a website and pulling the local time or weather in your area!</p>"},{"location":"arduino_example_5a_bluetooth_uart_service/","title":"Example 5a - Bluetooth UART Service","text":"<p>In the following two examples, we will connect two NORA-W306 development boards  via Bluetooth and send serial characters.</p>"},{"location":"arduino_example_5a_bluetooth_uart_service/#hardware-hookup","title":"Hardware Hookup","text":"<p>Connect the USB C cables to the boards and two different COM ports on your computer.</p> <p>Tip</p> <p>To keep track of which board that you are connecting to, use a sticky note and label the boards that you are using as the Service and Client.</p> USB Cable inserted into Thing Plus NORA-W306 <p>When connecting and disconnecting the boards from your computer, you will noticed that the COM port enumerates to a certain number from the menu Tools &gt; Port. Feel free to write down the COM port on the sticky note as well after uploading code.</p>"},{"location":"arduino_example_5a_bluetooth_uart_service/#arduino-code","title":"Arduino Code","text":"<p>Let's upload the sketch to send serial data between two SparkFun Thing Plus NORA-W306 boards wirelessly using the Bluetooth\u00ae Low Energy (BLE) feature. From the menu, select the following: File &gt; Examples &gt; File &gt; Examples &gt; Examples for SparkFun Thing Plus NORA-W306 (RTL8720DF) | AmebaBLE &gt; BLEUartService.</p> <p>Or you can copy and paste the following code in the Arduino IDE. Select the correct board definition from the menu (in this case, Tools &gt; Boards &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF)). Then select the correct COM port that the board enumerated to (in this case, it was COM13). Hit upload button.</p> <pre><code>/*\n\n Example guide:\n https://www.amebaiot.com/en/amebad-arduino-ble-uart-service/\n */\n\n#include \"BLEDevice.h\"\n\n#define UART_SERVICE_UUID      \"6E400001-B5A3-F393-E0A9-E50E24DCCA9E\"\n#define CHARACTERISTIC_UUID_RX \"6E400002-B5A3-F393-E0A9-E50E24DCCA9E\"\n#define CHARACTERISTIC_UUID_TX \"6E400003-B5A3-F393-E0A9-E50E24DCCA9E\"\n\n#define STRING_BUF_SIZE 100\n\nBLEService UartService(UART_SERVICE_UUID);\nBLECharacteristic Rx(CHARACTERISTIC_UUID_RX);\nBLECharacteristic Tx(CHARACTERISTIC_UUID_TX);\nBLEAdvertData advdata;\nBLEAdvertData scndata;\nbool notify = false;\n\nvoid readCB (BLECharacteristic* chr, uint8_t connID) {\n    Serial.print(\"Characteristic \");\n    Serial.print(chr-&gt;getUUID().str());\n    Serial.print(\" read by connection \");\n    Serial.println(connID);\n}\n\nvoid writeCB (BLECharacteristic* chr, uint8_t connID) {\n    Serial.print(\"Characteristic \");\n    Serial.print(chr-&gt;getUUID().str());\n    Serial.print(\" write by connection \");\n    Serial.println(connID);\n    if (chr-&gt;getDataLen() &gt; 0) {\n        Serial.print(\"Received string: \");\n        Serial.print(chr-&gt;readString());\n        Serial.println();\n    }\n}\n\nvoid notifCB(BLECharacteristic* chr, uint8_t connID, uint16_t cccd) {\n    if (cccd &amp; GATT_CLIENT_CHAR_CONFIG_NOTIFY) {\n        //printf(\"Notifications enabled on Characteristic %s for connection %d \\n\", chr-&gt;getUUID().str(), connID);\n        Serial.print(\"Notifications enabled on Characteristic\");\n        notify = true;\n    } else {\n        //printf(\"Notifications disabled on Characteristic %s for connection %d \\n\", chr-&gt;getUUID().str(), connID);\n        Serial.print(\"Notifications disabled on Characteristic\");\n        notify = false;\n    }\n    Serial.print(chr-&gt;getUUID().str());\n    Serial.print(\" for connection\");\n    Serial.println(connID);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n\n    advdata.addFlags(GAP_ADTYPE_FLAGS_LIMITED | GAP_ADTYPE_FLAGS_BREDR_NOT_SUPPORTED);\n    advdata.addCompleteName(\"AMEBA_BLE_DEV\");\n    scndata.addCompleteServices(BLEUUID(UART_SERVICE_UUID));\n\n    Rx.setWriteProperty(true);\n    Rx.setWritePermissions(GATT_PERM_WRITE);\n    Rx.setWriteCallback(writeCB);\n    Rx.setBufferLen(STRING_BUF_SIZE);\n    Tx.setReadProperty(true);\n    Tx.setReadPermissions(GATT_PERM_READ);\n    Tx.setReadCallback(readCB);\n    Tx.setNotifyProperty(true);\n    Tx.setCCCDCallback(notifCB);\n    Tx.setBufferLen(STRING_BUF_SIZE);\n\n    UartService.addCharacteristic(Rx);\n    UartService.addCharacteristic(Tx);\n\n    BLE.init();\n    BLE.configAdvert()-&gt;setAdvData(advdata);\n    BLE.configAdvert()-&gt;setScanRspData(scndata);\n    BLE.configServer(1);\n    BLE.addService(UartService);\n\n    BLE.beginPeripheral();\n}\n\nvoid loop() {\n    if (Serial.available()) {\n        Tx.writeString(Serial.readString());\n        if (BLE.connected(0) &amp;&amp; notify) {\n            Tx.notify(0);\n        }\n    }\n    delay(100);\n}\n</code></pre> <p>When finished uploading, head to the next section to upload code to a second SparkFun Thing Plus NORA-W306 board.</p>"},{"location":"arduino_example_5b_bluetooth_uart_client/","title":"Example 5b - Bluetooth UART Client","text":"<p>We will upload code for the Bluetooth UART client in this example. Then we will send characters between two serial terminals.</p>"},{"location":"arduino_example_5b_bluetooth_uart_client/#hardware-hookup","title":"Hardware Hookup","text":"<p>Connect the USB C cables to the boards and two different COM ports on your computer.</p> <p>Tip</p> <p>To keep track of which board that you are connecting to, use a sticky note and label the boards that you are using as the Service and Client.</p> USB Cable inserted into Thing Plus NORA-W306"},{"location":"arduino_example_5b_bluetooth_uart_client/#arduino-code","title":"Arduino Code","text":"<p>Let's upload the corresponding sketch to send serial data between two SparkFun Thing Plus NORA-W306 boards wirelessly using the Bluetooth\u00ae Low Energy (BLE) feature. From the menu, select the following: File &gt; Examples &gt; File &gt; Examples &gt; Examples for SparkFun Thing Plus NORA-W306 (RTL8720DF) | AmebaBLE &gt; BLEUartClient.</p> <p>Or you can copy and paste the following code in the Arduino IDE. Select the correct board definition from the menu (in this case, Tools &gt; Boards &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF)). Then select the correct COM port that the board enumerated to (in this case, it was COM22). Hit upload button.</p> <pre><code>/*\n\n Example guide:\n https://www.amebaiot.com/en/amebad-arduino-ble-uart/\n */\n\n#include \"BLEDevice.h\"\n\n#define UART_SERVICE_UUID      \"6E400001-B5A3-F393-E0A9-E50E24DCCA9E\"\n#define CHARACTERISTIC_UUID_RX \"6E400002-B5A3-F393-E0A9-E50E24DCCA9E\"\n#define CHARACTERISTIC_UUID_TX \"6E400003-B5A3-F393-E0A9-E50E24DCCA9E\"\n\n#define STRING_BUF_SIZE 100\n\nBLEAdvertData foundDevice;\nBLEAdvertData targetDevice;\nBLEClient* client;\nBLERemoteService* UartService;\nBLERemoteCharacteristic* Rx;\nBLERemoteCharacteristic* Tx;\n\nvoid scanCB(T_LE_CB_DATA* p_data) {\n    foundDevice.parseScanInfo(p_data);\n    if (foundDevice.hasName()) {\n        if (foundDevice.getName() == String(\"AMEBA_BLE_DEV\")) {\n            Serial.print(\"Found Ameba BLE Device at address \");\n            Serial.println(foundDevice.getAddr().str());\n            targetDevice = foundDevice;\n        }\n    }\n}\n\nvoid notificationCB (BLERemoteCharacteristic* chr, uint8_t* data, uint16_t len) {\n    char msg[len+1] = {0};\n    memcpy(msg, data, len);\n    Serial.print(\"Notification received for chr UUID: \");\n    Serial.println(chr-&gt;getUUID().str());\n    Serial.print(\"Received string: \");\n    Serial.println(String(msg));\n}\n\nvoid setup() {\n    Serial.begin(115200);\n\n    BLE.init();\n    BLE.setScanCallback(scanCB);\n    BLE.beginCentral(1);\n\n    BLE.configScan()-&gt;startScan(2000);\n    BLE.configConnection()-&gt;connect(targetDevice, 2000);\n    delay(2000);\n    int8_t connID = BLE.configConnection()-&gt;getConnId(targetDevice);\n    if (!BLE.connected(connID)) {\n        Serial.println(\"BLE not connected\");\n    } else {\n        BLE.configClient();\n        client = BLE.addClient(connID);\n        client-&gt;discoverServices();\n        Serial.print(\"Discovering services of connected device\");\n        do {\n            Serial.print(\".\");\n            delay(1000);\n        } while (!(client-&gt;discoveryDone()));\n        Serial.println();\n\n        UartService = client-&gt;getService(UART_SERVICE_UUID);\n        if (UartService != nullptr) {\n            Tx = UartService-&gt;getCharacteristic(CHARACTERISTIC_UUID_TX);\n            if (Tx != nullptr) {\n                Serial.println(\"TX characteristic found\");\n                Tx-&gt;setBufferLen(STRING_BUF_SIZE);\n                Tx-&gt;setNotifyCallback(notificationCB);\n                Tx-&gt;enableNotifyIndicate();\n            }\n            Rx = UartService-&gt;getCharacteristic(CHARACTERISTIC_UUID_RX);\n            if (Rx != nullptr) {\n                Serial.println(\"RX characteristic found\");\n                Rx-&gt;setBufferLen(STRING_BUF_SIZE);\n            }\n        }\n    }\n}\n\nvoid loop() {\n    if (Serial.available()) {\n        Rx-&gt;writeString(Serial.readString());\n    }\n    delay(100);\n}\n</code></pre> <p>To test, open the Arduino Serial Monitor for the client device on its respective COM port at 115200. Then open a second serial terminal (in this case we used TeraTerm) for the previous service device on its respective COM port at 115200. Type some characters and hit Send button from the client device. You should see the same characters received on the service device! Then try typing messages from the service to the client. Again, you should see the same characters on the other end. You may need to turn on the local echo depending on the terminal window that you are using.</p> BLE UART Service via Tera Term BLE UART Client via Arduino Serial Monitor"},{"location":"arduino_example_6_microsd/","title":"Example 6 - MicroSD Card","text":"<p>In this example, we will write some text to a microSD card and read the contents of the text file for verification.</p>"},{"location":"arduino_example_6_microsd/#hardware-hookup","title":"Hardware Hookup","text":"<p>Make sure to insert a microSD card into the microSD card socket on the back of the board.</p> MicroSD Card in Socket <p>When ready, connect the board to your computer with the USB C cable.</p>"},{"location":"arduino_example_6_microsd/#arduino-library","title":"Arduino Library","text":"<p>If you have not already, make sure to install the following library as explained earlier. Keep in mind there is more than one SdFat Arduino Library. We recommend using the SdFat Arduino Library by Bill Greiman.</p> <ul> <li>SdFat</li> </ul>"},{"location":"arduino_example_6_microsd/#arduino-code","title":"Arduino Code","text":"<p>Let's check your microSD card, write some text to a fill, and read hte contents of the file for verification</p> <p>Copy and paste the following code in the Arduino IDE. Select the correct board definition from the menu (in this case, Tools &gt; Boards &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF)). Then select the correct COM port that the board enumerated to (in this case, it was COM13). Hit upload button.</p> <pre><code>/*\nSparkFun Electronics\n7/17/2024\n\n\nSD card example for the SparkFun Thing Plus NORA-W306\n\n\nNote, the SparkFun Thing Plus NORA-W306 does not use the SDIO hardware peripheral.\nIt utilizes SPI0 to communicate with the uSD card.\n\n\nUsing sdFAT and the onboard uSD socket (SPI0), this program attempts to:\n\n  1. Initialize an SD card and analyze its structure.\n\n\n  2. Create a file on the SD card and write a string to it.\n\n\n  3. Open the file and print the contents to the serial monitor.\n\n\nHardware Hookup and Instructions:\n  Insert an SD card into the SD card slot on the NORA-W306.\n  Connect the NORA-W306 to your computer using a USB-C cable.\n  Upload this code to the NORA-W306.\n  Open the serial monitor to see the results.\n\n\nSoftware versions used in this example:\n  Arduino IDE 2.3.2\n  usdFAT by Bill Greiman, Arduino Library Version 2.2.3\n    (https://github.com/greiman/SdFat)\n  Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz) by Realtek Version 3.1.8\n    (https://github.com/ambiot/ambd_arduino)\n    (https://raw.githubusercontent.com/ambiot/ambd_arduino/dev/Arduino_package/package_realtek_amebad_early_index.json)\n\n\nOriginal code is from the following two examples in the SdFat library:\n  SdInfo - Program to read and display SD card information\n    -MIT License, Copyright (c) 2011..2020 Bill Greiman\n  examplesV1/ReadWrite - Program to test read and write functions\n    -Public Domain, created Nov 2010 by David A. Mellis, modified 9 Apr 2012 by Tom Igoe\n\n\nMIT License\n\n\nCopyright (c) 2024 SparkFun Electronics\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in the\nSoftware without restriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\nSoftware, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n#include \"SdFat.h\"\n#include \"sdios.h\"\n\n\nFile myFile;\n\n\n/*\n  Set DISABLE_CS_PIN to disable a second SPI device.\n  For example, with the Ethernet shield, set DISABLE_CS_PIN\n  to 10 to disable the Ethernet controller.\n*/\nconst int8_t DISABLE_CS_PIN = -1;\n/*\n  Change the value of SD_CS_PIN if you are using SPI\n  and your hardware does not use the default value, SS.\n  Common values are:\n  Arduino Ethernet shield: pin 4\n  Sparkfun SD shield: pin 8\n  Adafruit SD shields and modules: pin 10\n  SparkFun Thing Plus NORA-W306: Arduino pin 4 (aka SS/PB_21/SPI0_CS)\n*/\n// SDCARD_SS_PIN is defined for the built-in SD on some boards.\n#ifndef SDCARD_SS_PIN\nconst uint8_t SD_CS_PIN = SS;\n#else   // SDCARD_SS_PIN\nconst uint8_t SD_CS_PIN = SDCARD_SS_PIN;\n#endif  // SDCARD_SS_PIN\n\n\n// Try to select the best SD card configuration.\n#if HAS_SDIO_CLASS\n#define SD_CONFIG SdioConfig(FIFO_SDIO)\n#elif ENABLE_DEDICATED_SPI\n#define SD_CONFIG SdSpiConfig(SD_CS_PIN, DEDICATED_SPI, SD_SCK_MHZ(16))\n#else  // HAS_SDIO_CLASS\n#define SD_CONFIG SdSpiConfig(SD_CS_PIN, SHARED_SPI, SD_SCK_MHZ(16))\n#endif  // HAS_SDIO_CLASS\n\n\n//------------------------------------------------------------------------------\nSdFs sd;\ncid_t cid;\ncsd_t csd;\nscr_t scr;\nuint8_t cmd6Data[64];\nuint32_t eraseSize;\nuint32_t ocr;\nstatic ArduinoOutStream cout(Serial);\n//------------------------------------------------------------------------------\nvoid cidDmp() {\n  cout &lt;&lt; F(\"\\nManufacturer ID: \");\n  cout &lt;&lt; uppercase &lt;&lt; showbase &lt;&lt; hex &lt;&lt; int(cid.mid) &lt;&lt; dec &lt;&lt; endl;\n  cout &lt;&lt; F(\"OEM ID: \") &lt;&lt; cid.oid[0] &lt;&lt; cid.oid[1] &lt;&lt; endl;\n  cout &lt;&lt; F(\"Product: \");\n  for (uint8_t i = 0; i &lt; 5; i++) {\n    cout &lt;&lt; cid.pnm[i];\n  }\n  cout &lt;&lt; F(\"\\nRevision: \") &lt;&lt; cid.prvN() &lt;&lt; '.' &lt;&lt; cid.prvM() &lt;&lt; endl;\n  cout &lt;&lt; F(\"Serial number: \") &lt;&lt; hex &lt;&lt; cid.psn() &lt;&lt; dec &lt;&lt; endl;\n  cout &lt;&lt; F(\"Manufacturing date: \");\n  cout &lt;&lt; cid.mdtMonth() &lt;&lt; '/' &lt;&lt; cid.mdtYear() &lt;&lt; endl;\n  cout &lt;&lt; endl;\n}\n//------------------------------------------------------------------------------\nvoid clearSerialInput() {\n  uint32_t m = micros();\n  do {\n    if (Serial.read() &gt;= 0) {\n      m = micros();\n    }\n  } while (micros() - m &lt; 10000);\n}\n//------------------------------------------------------------------------------\nvoid csdDmp() {\n  eraseSize = csd.eraseSize();\n  cout &lt;&lt; F(\"cardSize: \") &lt;&lt; 0.000512 * csd.capacity();\n  cout &lt;&lt; F(\" MB (MB = 1,000,000 bytes)\\n\");\n\n\n\n\n  cout &lt;&lt; F(\"flashEraseSize: \") &lt;&lt; int(eraseSize) &lt;&lt; F(\" blocks\\n\");\n  cout &lt;&lt; F(\"eraseSingleBlock: \");\n  if (csd.eraseSingleBlock()) {\n    cout &lt;&lt; F(\"true\\n\");\n  } else {\n    cout &lt;&lt; F(\"false\\n\");\n  }\n  cout &lt;&lt; F(\"dataAfterErase: \");\n  if (scr.dataAfterErase()) {\n    cout &lt;&lt; F(\"ones\\n\");\n  } else {\n    cout &lt;&lt; F(\"zeros\\n\");\n  }\n}\n//------------------------------------------------------------------------------\nvoid errorPrint() {\n  if (sd.sdErrorCode()) {\n    cout &lt;&lt; F(\"SD errorCode: \") &lt;&lt; hex &lt;&lt; showbase;\n    printSdErrorSymbol(&amp;Serial, sd.sdErrorCode());\n    cout &lt;&lt; F(\" = \") &lt;&lt; int(sd.sdErrorCode()) &lt;&lt; endl;\n    cout &lt;&lt; F(\"SD errorData = \") &lt;&lt; int(sd.sdErrorData()) &lt;&lt; dec &lt;&lt; endl;\n  }\n}\n//------------------------------------------------------------------------------\nbool mbrDmp() {\n  MbrSector_t mbr;\n  bool valid = true;\n  if (!sd.card()-&gt;readSector(0, (uint8_t *)&amp;mbr)) {\n    cout &lt;&lt; F(\"\\nread MBR failed.\\n\");\n    errorPrint();\n    return false;\n  }\n  cout &lt;&lt; F(\"\\nSD Partition Table\\n\");\n  cout &lt;&lt; F(\"part,boot,bgnCHS[3],type,endCHS[3],start,length\\n\");\n  for (uint8_t ip = 1; ip &lt; 5; ip++) {\n    MbrPart_t *pt = &amp;mbr.part[ip - 1];\n    if ((pt-&gt;boot != 0 &amp;&amp; pt-&gt;boot != 0X80) || getLe32(pt-&gt;relativeSectors) &gt; csd.capacity()) {\n      valid = false;\n    }\n    cout &lt;&lt; int(ip) &lt;&lt; ',' &lt;&lt; uppercase &lt;&lt; showbase &lt;&lt; hex;\n    cout &lt;&lt; int(pt-&gt;boot) &lt;&lt; ',';\n    for (int i = 0; i &lt; 3; i++) {\n      cout &lt;&lt; int(pt-&gt;beginCHS[i]) &lt;&lt; ',';\n    }\n    cout &lt;&lt; int(pt-&gt;type) &lt;&lt; ',';\n    for (int i = 0; i &lt; 3; i++) {\n      cout &lt;&lt; int(pt-&gt;endCHS[i]) &lt;&lt; ',';\n    }\n    cout &lt;&lt; dec &lt;&lt; getLe32(pt-&gt;relativeSectors) &lt;&lt; ',';\n    cout &lt;&lt; getLe32(pt-&gt;totalSectors) &lt;&lt; endl;\n  }\n  if (!valid) {\n    cout &lt;&lt; F(\"\\nMBR not valid, assuming Super Floppy format.\\n\");\n  }\n  return true;\n}\n//------------------------------------------------------------------------------\nvoid dmpVol() {\n  cout &lt;&lt; F(\"\\nScanning FAT, please wait.\\n\");\n  int32_t freeClusterCount = sd.freeClusterCount();\n  if (sd.fatType() &lt;= 32) {\n    cout &lt;&lt; F(\"\\nVolume is FAT\") &lt;&lt; int(sd.fatType()) &lt;&lt; endl;\n  } else {\n    cout &lt;&lt; F(\"\\nVolume is exFAT\\n\");\n  }\n  cout &lt;&lt; F(\"sectorsPerCluster: \") &lt;&lt; sd.sectorsPerCluster() &lt;&lt; endl;\n  cout &lt;&lt; F(\"fatStartSector:    \") &lt;&lt; sd.fatStartSector() &lt;&lt; endl;\n  cout &lt;&lt; F(\"dataStartSector:   \") &lt;&lt; sd.dataStartSector() &lt;&lt; endl;\n  cout &lt;&lt; F(\"clusterCount:      \") &lt;&lt; sd.clusterCount() &lt;&lt; endl;\n  cout &lt;&lt; F(\"freeClusterCount:  \");\n  if (freeClusterCount &gt;= 0) {\n    cout &lt;&lt; freeClusterCount &lt;&lt; endl;\n  } else {\n    cout &lt;&lt; F(\"failed\\n\");\n    errorPrint();\n  }\n}\n//------------------------------------------------------------------------------\nvoid printCardType() {\n  cout &lt;&lt; F(\"\\nCard type: \");\n  switch (sd.card()-&gt;type()) {\n    case SD_CARD_TYPE_SD1:\n      cout &lt;&lt; F(\"SD1\\n\");\n      break;\n    case SD_CARD_TYPE_SD2:\n      cout &lt;&lt; F(\"SD2\\n\");\n      break;\n    case SD_CARD_TYPE_SDHC:\n      if (csd.capacity() &lt; 70000000) {\n        cout &lt;&lt; F(\"SDHC\\n\");\n      } else {\n        cout &lt;&lt; F(\"SDXC\\n\");\n      }\n      break;\n    default:\n      cout &lt;&lt; F(\"Unknown\\n\");\n  }\n}\n//------------------------------------------------------------------------------\nvoid printConfig(SdSpiConfig config) {\n  if (DISABLE_CS_PIN &lt; 0) {\n    cout &lt;&lt; F(\n      \"\\nAssuming the SD is the only SPI device.\\n\"\n      \"Edit DISABLE_CS_PIN to disable an SPI device.\\n\");\n  } else {\n    cout &lt;&lt; F(\"\\nDisabling SPI device on pin \");\n    cout &lt;&lt; int(DISABLE_CS_PIN) &lt;&lt; endl;\n    pinMode(DISABLE_CS_PIN, OUTPUT);\n    digitalWrite(DISABLE_CS_PIN, HIGH);\n  }\n  cout &lt;&lt; F(\"\\nAssuming the SD chip select pin is: \") &lt;&lt; int(config.csPin);\n  cout &lt;&lt; F(\"\\nEdit SD_CS_PIN to change the SD chip select pin.\\n\");\n}\n//------------------------------------------------------------------------------\nvoid printConfig(SdioConfig config) {\n  (void)config;\n  cout &lt;&lt; F(\"Assuming an SDIO interface.\\n\");\n}\n//-----------------------------------------------------------------------------\nvoid setup() {\n  Serial.begin(9600);\n  // Wait for USB Serial\n  while (!Serial) {\n    yield();\n  }\n  cout &lt;&lt; F(\"SdFat version: \") &lt;&lt; SD_FAT_VERSION_STR &lt;&lt; endl;\n  printConfig(SD_CONFIG);\n}\n//------------------------------------------------------------------------------\nvoid loop() {\n  // Read any existing Serial data.\n  clearSerialInput();\n\n\n  // F stores strings in flash to save RAM\n  cout &lt;&lt; F(\"\\ntype any character to start\\n\");\n  while (!Serial.available()) {\n    yield();\n  }\n  uint32_t t = millis();\n  if (!sd.cardBegin(SD_CONFIG)) {\n    cout &lt;&lt; F(\n      \"\\nSD initialization failed.\\n\"\n      \"Do not reformat the card!\\n\"\n      \"Is the card correctly inserted?\\n\"\n      \"Is there a wiring/soldering problem?\\n\");\n    if (isSpi(SD_CONFIG)) {\n      cout &lt;&lt; F(\n        \"Is SD_CS_PIN set to the correct value?\\n\"\n        \"Does another SPI device need to be disabled?\\n\");\n    }\n    errorPrint();\n    return;\n  }\n  t = millis() - t;\n  cout &lt;&lt; F(\"init time: \") &lt;&lt; dec &lt;&lt; t &lt;&lt; \" ms\" &lt;&lt; endl;\n\n\n  if (!sd.card()-&gt;readCID(&amp;cid) || !sd.card()-&gt;readCSD(&amp;csd) || !sd.card()-&gt;readOCR(&amp;ocr) || !sd.card()-&gt;readSCR(&amp;scr)) {\n    cout &lt;&lt; F(\"readInfo failed\\n\");\n    errorPrint();\n    return;\n  }\n  printCardType();\n  cout &lt;&lt; F(\"sdSpecVer: \") &lt;&lt; 0.01 * scr.sdSpecVer() &lt;&lt; endl;\n  cout &lt;&lt; F(\"HighSpeedMode: \");\n  if (scr.sdSpecVer() &amp;&amp; sd.card()-&gt;cardCMD6(0X00FFFFFF, cmd6Data) &amp;&amp; (2 &amp; cmd6Data[13])) {\n    cout &lt;&lt; F(\"true\\n\");\n  } else {\n    cout &lt;&lt; F(\"false\\n\");\n  }\n  cidDmp();\n  csdDmp();\n  cout &lt;&lt; F(\"\\nOCR: \") &lt;&lt; uppercase &lt;&lt; showbase;\n  cout &lt;&lt; hex &lt;&lt; ocr &lt;&lt; dec &lt;&lt; endl;\n  if (!mbrDmp()) {\n    return;\n  }\n  if (!sd.volumeBegin()) {\n    cout &lt;&lt; F(\"\\nvolumeBegin failed. Is the card formatted?\\n\");\n    errorPrint();\n    return;\n  }\n  dmpVol();\n  test();\n}\n//------------------------------------------------------------------------------\nvoid test() {\n  // open the file. note that only one file can be open at a time,\n  // so you have to close this one before opening another.\n  myFile = sd.open(\"test.txt\", FILE_WRITE);\n\n\n  // if the file opened okay, write to it:\n  if (myFile) {\n    Serial.print(\"Writing to test.txt...\");\n    myFile.println(\"testing 3,4,5 wahoo\");\n    // close the file:\n    myFile.close();\n    Serial.println(\"done.\");\n  } else {\n    // if the file didn't open, print an error:\n    Serial.println(\"error opening test.txt\");\n  }\n\n\n  // re-open the file for reading:\n  myFile = sd.open(\"test.txt\");\n  if (myFile) {\n    Serial.println(\"test.txt:\");\n\n\n\n\n    // read from the file until there's nothing else in it:\n    while (myFile.available()) {\n      Serial.write(myFile.read());\n    }\n    // close the file:\n    myFile.close();\n  } else {\n    // if the file didn't open, print an error:\n    Serial.println(\"error opening test.txt\");\n  }\n}\n</code></pre> <p>Open the Arduino Serial Monitor at 115200 baud. Send a character through the Arduino Serial Monitor. You should get a prompt in the Serial Monitor. Enter a chararacter (i.e. send s or any other keyboard character) to start. The example will then read the card. If the card is compatible, the output will provide information about the microSD card type, create a new file, write text to the file, and then close the file. The example will then re-open the file and read the contents of the file. You should see the following text in the file: \"testing 3,4,5 wahoo\". If the example code is run more than once, you may see the same text repeat a few times.</p> MicroSD Card Test Output <p>To open using the a file explorer, you can disconnect the SparkFun Thing Plus - NORA-W306, remove the microSD card, and connect it to a computer with a microSD card adapter. Once connected, you can open the test.txt file with a text editor to verify the text written in the file.</p> File Explorer Text Editor Verification"},{"location":"arduino_example_7_deep_sleep_blink/","title":"Example 7 - Deep Sleep and Blink","text":"<p>In this example, we will show how to set your board in deep sleep, blink the user LED as an indicator, and then go back into power saving mode.</p> <p>Note</p> <p>This is a modified example from the Realtek's Arduino example for Deep Sleep Mode.</p>"},{"location":"arduino_example_7_deep_sleep_blink/#hardware-hookup","title":"Hardware Hookup","text":"<p>For users interested in measuring the current draw via the MEAS jumper, you can cut the trace located on the back of the board. Power the board via USB or battery. Then place a multimeter set to measure current on the PTHs. This makes it easier to measure the current as opposed to measuring the current between the power source and connector.</p> <p>Note</p> <p>The MEAS jumper is before the XC6222 3.3V voltage regulator. For users that are connecting power to the 3V3 pin or Qwiic connector, you will need to place a multimeter between the regulated 3.3V power source and the board.</p> MEAS Jumper Modified <p>To upload code, connect the USB cable to the SparkFun Thing Plus NORA-W306. Of course, make sure to connect the other end to your computer.</p> USB Cable inserted into Thing Plus NORA-W306 <p>Tip</p> <p>Make sure to add a solder blob on the MEAS jumper when finished measuring. Users can also solder a 2-pin male header and shunt to the PTHs to easily remove/add the connection.</p>"},{"location":"arduino_example_7_deep_sleep_blink/#arduino-code","title":"Arduino Code","text":"<p>This example builds upon Realtek's deep sleep mode. Once the deep sleep modes are set up, the NORA-W306 goes into deep sleep. In this particular example, we will use the timer (i.e. <code>SET_DS_AON_TIMER_WAKEUP</code>) as the source. After 5 seconds, the board wakes up with the user LED also blinking five times before going back to deep sleep for 5 seconds.</p> <p>Note</p> <p>The serial UART is disabled to reduce amount the peripherals that are turned on. To save more power, you can cut the JP3 and PWR LED jumpers. There is also a fancy circuit to disable power to the CP2102 when there is no USB power. As an alternative to USB power, users can power the board with a LiPo battery.</p> <p>Copy and paste the following code in the Arduino IDE. Select your Board (in this case the SparkFun Thing Plus NORA-W306 (RTL8720DF)), and associated COM port (in this case COM13). Then hit the upload button.</p> <pre><code>/*\n* SparkFun Electronics\n* 7/17/2024\n*\n* SparkFun_ThingPlus_NORAW306_DeepSleepBlink.ino\n*\n* Deep Sleep mode example for the SparkFun Thing Plus NORA-W306\n*\n* This example demonstrates how to put the NORA-W306 into deep sleep mode and\n* wake it up using the AON timer (every 5 seconds).\n* When awake, the onboard LED will blink.\n* When asleep, the current consumption can be monitored using the MEAS jumper.\n*\n* Hardware Hookup and Instructions:\n*   Connect the NORA-W306 to your computer using a USB-C cable.\n*   Upload this code to the NORA-W306.\n*   To measure the low-power consumption of the NORA-W306, remove USB-C cable\n*   and utilize the MEAS jumper to measure the current consumption.\n*   \n* Software versions used in this example:\n*   Arduino IDE 2.3.2\n*   Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz) by Realtek Version 3.1.8\n*     (https://github.com/ambiot/ambd_arduino)\n*     (https://raw.githubusercontent.com/ambiot/ambd_arduino/dev/Arduino_package/package_realtek_amebad_early_index.json)\n*\n* Original code is from the following example in the RealTek Ameba Arduino package:\n*  Examples -&gt; AmebaPowerSave -&gt; DeepSleepMode.ino\n*\n* MIT License\n*\n* Copyright (c) 2024 SparkFun Electronics\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy of\n* this software and associated documentation files (the \"Software\"), to deal in the\n* Software without restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n* PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#include &lt;PowerSave.h&gt;\n\n//SET_DS_AON_TIMER_WAKEUP\n//SET_DS_RTC_WAKEUP\n//For AMB21/22 only the AON GPIO pins listed below should be selected\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 16\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 17\n    //SET_AON_GPIO_WAKEUP_PA21          // pin 26\n    //SET_AON_GPIO_WAKEUP_PA20          // pin 27\n    //SET_AON_GPIO_WAKEUP_PA19          // pin 28\n//For AMB23 only the AON GPIO pins listed below should be selected\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 9\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 10\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 11\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 12\n    //SET_AON_GPIO_WAKEUP_PA16          // pin 13\n    //SET_AON_GPIO_WAKEUP_PA18          // pin 15\n    //SET_AON_GPIO_WAKEUP_PA19          // pin 16\n    //SET_AON_GPIO_WAKEUP_PA21          // pin 18\n//For BW16/BW16-TypeC only the AON GPIO pins listed below should be selected\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 7\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 8\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 9\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 10\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 11\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 12\n//For board AW-CU488_ThingPlus\n    //SET_AON_GPIO_WAKEUP_PA18          // pin 0\n    //SET_AON_GPIO_WAKEUP_PA16          // pin 1\n    //SET_AON_GPIO_WAKEUP_PA17          // pin 2\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 3\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 4\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 5\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 6\n    //SET_AON_GPIO_WAKEUP_PA19          // pin 8\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 28\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 29\n//For board AMB25/AMB26\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 3\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 2\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 1\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 0\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 7\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 6\n//For board SparkFun Thing Plus NORA-W306\n    //SET_AON_GPIO_WAKEUP_PA18          // pin 6\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 13\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 14\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 11\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 12\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 15\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 16\n\n#define DS_WAKEUP_SOURCE                SET_DS_AON_TIMER_WAKEUP\n\n#define AON_TIMER_SLEEP_DURATION        5000\n#define DS_RTC_ALARM_DAY                0\n#define DS_RTC_ALARM_HOUR               0\n#define DS_RTC_ALARM_MIN                0\n#define DS_RTC_ALARM_SEC                10\n\nvoid DeepSleep_wakeup(void) {\n    //printf(\"\\r\\nDeep sleep wakeuped! \\r\\n\");\n    uint32_t wakereason_number = PowerSave.AONWakeReason();\n\n    //pinMode(17, OUTPUT); // 17 SDPC uSD power control\n    //digitalWrite(17, LOW); // Turn on uSD power if you'd like to measure its current consumption   \n\n    if (wakereason_number == AONWakeReason_AON_GPIO) {\n        //printf(\"AonWakepin wakeup. Wait 5s sleep again.    \\r\\n\");\n        delay(5000);\n    } else if (wakereason_number == AONWakeReason_AON_TIMER) {\n        PowerSave.AONTimerCmd();\n        //printf(\"AonTimer wakeup. Wait 5s sleep again.    \\r\\n\");\n\n        pinMode(LED_BUILTIN, OUTPUT);\n        for(int i = 0 ; i &lt; 5 ; i ++)\n        {\n          digitalWrite(LED_BUILTIN, HIGH);\n          delay(1000);\n          digitalWrite(LED_BUILTIN, LOW);\n          delay(1000);\n        }\n        pinMode(LED_BUILTIN, INPUT);\n        //delay(5000);\n    } else if (wakereason_number == AONWakeReason_RTC) {\n        //printf(\"RTC wakeup. Wait 5s sleep again.    \\r\\n\");\n        delay(5000);\n    }\n\n    //pinMode(17, INPUT_PULLUP); // 17 SDPC uSD power control (Pullup = off)\n\n    PowerSave.AONWakeClear();\n}\n\nvoid setup() {\n    // If you want serial debug messages, uncomment the following lines and others\n    // below, as desired.\n    // Open serial communications and wait for port to open:\n    // Serial.begin(115200);\n    // while (!Serial) {\n    //     ; // wait for serial port to connect. Needed for native USB port only\n    // }\n\n    // Pin configuration - specific to the SparkFun Thing Plus NORA-W306\n\n    pinMode(0, INPUT_PULLDOWN); // LOG RX, can backpower the CP2102\n    pinMode(1, INPUT_PULLDOWN); // LOG TX, can backpower the CP2102\n    pinMode(4, INPUT_PULLDOWN); // SPI0_CS, can sink current from 3V3 via R16 (100K), note, this is only possible if you leave uSD power on\n    pinMode(5, INPUT_PULLDOWN); // SPI0_CLK\n    pinMode(6, INPUT_PULLDOWN); // SPI0_PICO\n    pinMode(7, INPUT_PULLDOWN); // SPI0_POCI\n\n    pinMode(11, INPUT_PULLUP); // SDA\n    pinMode(12, INPUT_PULLUP); // SCL\n    pinMode(17, INPUT_PULLUP); // 17 SDPC uSD power control\n    pinMode(20, INPUT_PULLNONE); // aka PB_24, this is tied internally to PB_23 (aka Arduino pin \"17\") and also defaults to internal pulldown.\n\n    PowerSave.begin(DEEPSLEEP_MODE);\n\n    if (TRUE == (PowerSave.DsleepWakeStatusGet())) {\n        DeepSleep_wakeup();\n    }\n\n    PowerSave.AONTimerDuration(0);\n\n    switch (DS_WAKEUP_SOURCE) {\n        case SET_DS_AON_TIMER_WAKEUP:\n            PowerSave.DS_AON_TIMER_WAKEUP();\n            PowerSave.AONTimerDuration(AON_TIMER_SLEEP_DURATION);\n            break;\n        case SET_DS_RTC_WAKEUP:\n            PowerSave.DS_RTC_WAKEUP();\n            PowerSave.RTCWakeSetup(DS_RTC_ALARM_DAY, DS_RTC_ALARM_HOUR, DS_RTC_ALARM_MIN, DS_RTC_ALARM_SEC);\n            break;\n        case SET_AON_GPIO_WAKEUP_PA12:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA12();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA13:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA13();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA14:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA14();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA15:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA15();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA16:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA16();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA17:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA17();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA18:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA18();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA19:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA19();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA20:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA20();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA21:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA21();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA25:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA25();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA26:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA26();\n            break;\n        default:\n            printf(\"Unknown wakeup source.    \\r\\n\");\n        break;\n    }\n\n    PowerSave.enable();\n}\n\nvoid loop() {\n    delay(1000);\n}\n</code></pre> <p>Once connected, choose a power source to connect to the SparkFun Thing Plus NORA-W306. This can be through the PTHs on the edge of the board (VU, VB, or 3V3) or the connectors (USB C, 2-pin JST, or Qwiic). Note that the board will draw more power through the USB C connector and VU PTH as this will power the CP2102. Power will also be drawn with the LiPo charger and 3.3V voltage regulator.</p> <p>Below are a few diagrams showing two possible ways to measure the current draw when the board is in deep sleep mode.</p> Fritzing Diagram of Multimeter Measuring Current through MEAS and a LiPo Battery as the Power Source Fritzing Diagram of Multimeter Measuring Current LiPo Battery and Board <p>If you haven't already, check out the demo video that was linked earlier in the hardware overview showing the current draw for the board in low power mode!</p>"},{"location":"arduino_example_8_deep_sleep_temperature_datalogging_BME280/","title":"Example 8 - Deep Sleep and MicroSD Temperature DataLogging","text":"<p>In this example, we will read sensor readings from a BME280, log the data to a microSD card, and then go into deep sleep.</p>"},{"location":"arduino_example_8_deep_sleep_temperature_datalogging_BME280/#hardware-hookup","title":"Hardware Hookup","text":"<p>To take advantage of the SD power control (SDPC), you will need to make sure to cut the trace on the back of the board and add a solder blob between the center pad and pad labeled as <code>17</code>.</p> MicroSD Card Power Control Jumper Modified <p>When ready, insert a microSD card into the socket on the back of the board. Then connect the Qwiic BME280 to the SparkFun Thing Plus NORA-W306 using a Qwiic cable.</p> Fritzing Diagram BME280 connected to NORA-W306 via Qwiic <p>Connect a USB cable to the board to power and upload code.</p>"},{"location":"arduino_example_8_deep_sleep_temperature_datalogging_BME280/#arduino-code","title":"Arduino Code","text":"<p>This example builds upon Realtek's deep sleep like the previous example. In addition to blinking the LED, we will also read the temperature from a BME280 and write the sensor data to the microSD card.</p> <p>Copy and paste the following code in the Arduino IDE. Select your Board (in this case the SparkFun Thing Plus NORA-W306 (RTL8720DF)), and associated COM port (in this case COM23). Then hit the upload button.</p> <pre><code>/*\n* SparkFun Electronics\n* 7/17/2024\n*\n* SparkFun_ThingPlus_NORAW306_DeepSleepTempLogger.ino\n*\n* Deep Sleep mode with data logging  - example for the SparkFun Thing Plus NORA-W306\n*\n* This example demonstrates how to put the NORA-W306 into deep sleep mode and\n* wake it up using the AON timer (every 5 seconds).\n* When awake, it will log the temperature from the BME280 sensor to the uSD card.\n* When awake, it will also blink the stat LED three times to indicate a log has happened.\n* When asleep, the current consumption can be monitored using the MEAS jumper.\n*\n* Hardware Hookup and Instructions:\n*   Connect the NORA-W306 to your computer using a USB-C cable.\n*   Connect the BME280 sensor with a Qwiic Cable.\n*   Upload this code to the NORA-W306.\n*   To measure the low-power consumption of the NORA-W306, remove USB-C cable\n*   and utilize the MEAS jumper to measure the current consumption.\n*   \n* Software versions used in this example:\n*   Arduino IDE 2.3.2\n*   Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz) by Realtek Version 3.1.8\n*     (https://github.com/ambiot/ambd_arduino)\n*     (https://raw.githubusercontent.com/ambiot/ambd_arduino/dev/Arduino_package/package_realtek_amebad_early_index.json)\n*   BME280 library by SparkFun Electronics\n*     (https://github.com/sparkfun/SparkFun_BME280_Arduino_Library)\n*\n* Original code is from the following example in the RealTek Ameba Arduino package:\n*  Examples -&gt; AmebaPowerSave -&gt; DeepSleepMode.ino\n*\n* MIT License\n*\n* Copyright (c) 2024 SparkFun Electronics\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy of\n* this software and associated documentation files (the \"Software\"), to deal in the\n* Software without restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n* PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n// variables to store the readings from the sensor\nfloat humidity;\nfloat pressure;\nfloat altitude;\nfloat temperature;\n\n#include \"SdFat.h\"\n#include \"sdios.h\"\n\nFile myFile;\n\n/*\n  Set DISABLE_CS_PIN to disable a second SPI device.\n  For example, with the Ethernet shield, set DISABLE_CS_PIN\n  to 10 to disable the Ethernet controller.\n*/\nconst int8_t DISABLE_CS_PIN = -1;\n/*\n  Change the value of SD_CS_PIN if you are using SPI\n  and your hardware does not use the default value, SS.\n  Common values are:\n  Arduino Ethernet shield: pin 4\n  Sparkfun SD shield: pin 8\n  Adafruit SD shields and modules: pin 10\n  SparkFun Thing Plus NORA-W306: Arduino pin 4 (aka SS/PB_21/SPI0_CS)\n*/\n// SDCARD_SS_PIN is defined for the built-in SD on some boards.\n#ifndef SDCARD_SS_PIN\nconst uint8_t SD_CS_PIN = SS;\n#else  // SDCARD_SS_PIN\nconst uint8_t SD_CS_PIN = SDCARD_SS_PIN;\n#endif  // SDCARD_SS_PIN\n\n// Try to select the best SD card configuration.\n#if HAS_SDIO_CLASS\n#define SD_CONFIG SdioConfig(FIFO_SDIO)\n#elif ENABLE_DEDICATED_SPI\n#define SD_CONFIG SdSpiConfig(SD_CS_PIN, DEDICATED_SPI, SD_SCK_MHZ(16))\n#else  // HAS_SDIO_CLASS\n#define SD_CONFIG SdSpiConfig(SD_CS_PIN, SHARED_SPI, SD_SCK_MHZ(16))\n#endif  // HAS_SDIO_CLASS\n\n//------------------------------------------------------------------------------\nSdFs sd;\ncid_t cid;\ncsd_t csd;\nscr_t scr;\nuint8_t cmd6Data[64];\nuint32_t eraseSize;\nuint32_t ocr;\nstatic ArduinoOutStream cout(Serial);\n\n\n#include &lt;Wire.h&gt;\n\n#include \"SparkFunBME280.h\"\nBME280 mySensor;\n\n#include &lt;PowerSave.h&gt;\n\n//SET_DS_AON_TIMER_WAKEUP\n//SET_DS_RTC_WAKEUP\n//For AMB21/22 only the AON GPIO pins listed below should be selected\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 16\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 17\n    //SET_AON_GPIO_WAKEUP_PA21          // pin 26\n    //SET_AON_GPIO_WAKEUP_PA20          // pin 27\n    //SET_AON_GPIO_WAKEUP_PA19          // pin 28\n//For AMB23 only the AON GPIO pins listed below should be selected\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 9\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 10\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 11\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 12\n    //SET_AON_GPIO_WAKEUP_PA16          // pin 13\n    //SET_AON_GPIO_WAKEUP_PA18          // pin 15\n    //SET_AON_GPIO_WAKEUP_PA19          // pin 16\n    //SET_AON_GPIO_WAKEUP_PA21          // pin 18\n//For BW16/BW16-TypeC only the AON GPIO pins listed below should be selected\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 7\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 8\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 9\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 10\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 11\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 12\n//For board AW-CU488_ThingPlus\n    //SET_AON_GPIO_WAKEUP_PA18          // pin 0\n    //SET_AON_GPIO_WAKEUP_PA16          // pin 1\n    //SET_AON_GPIO_WAKEUP_PA17          // pin 2\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 3\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 4\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 5\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 6\n    //SET_AON_GPIO_WAKEUP_PA19          // pin 8\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 28\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 29\n//For board AMB25/AMB26\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 3\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 2\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 1\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 0\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 7\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 6\n//For board SparkFun Thing Plus NORA-W306\n    //SET_AON_GPIO_WAKEUP_PA18          // pin 6\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 13\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 14\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 11\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 12\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 15\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 16\n\n#define DS_WAKEUP_SOURCE                SET_DS_AON_TIMER_WAKEUP\n\n#define AON_TIMER_SLEEP_DURATION        5000\n#define DS_RTC_ALARM_DAY                0\n#define DS_RTC_ALARM_HOUR               0\n#define DS_RTC_ALARM_MIN                0\n#define DS_RTC_ALARM_SEC                10\n\nvoid DeepSleep_wakeup(void) {\n    //printf(\"\\r\\nDeep sleep wakeuped! \\r\\n\");\n    uint32_t wakereason_number = PowerSave.AONWakeReason();\n\n    readSensor();\n\n    if (wakereason_number == AONWakeReason_AON_GPIO) {\n        //printf(\"AonWakepin wakeup. Wait 5s sleep again.    \\r\\n\");\n        delay(5000);\n    } else if (wakereason_number == AONWakeReason_AON_TIMER) {\n        PowerSave.AONTimerCmd();\n        //printf(\"AonTimer wakeup. Wait 5s sleep again.    \\r\\n\");\n\n        pinMode(LED_BUILTIN, OUTPUT);\n        for(int i = 0 ; i &lt; 3 ; i ++)\n        {\n          digitalWrite(LED_BUILTIN, HIGH);\n          delay(100);\n          digitalWrite(LED_BUILTIN, LOW);\n          delay(100);\n        }\n        pinMode(LED_BUILTIN, INPUT);\n        //delay(5000);\n    } else if (wakereason_number == AONWakeReason_RTC) {\n\n        printf(\"RTC wakeup. Wait 5s sleep again.    \\r\\n\");\n\n        delay(5000);\n    }\n\n    pinMode(0, INPUT_PULLDOWN); // LOG RX, can backpower the CP2102\n    pinMode(1, INPUT_PULLDOWN); // LOG TX, can backpower the CP2102\n    pinMode(4, INPUT_PULLDOWN); // SPI0_CS, can sink current from 3V3 via R16 (100K), note, this is only possible if you leave uSD power on\n    pinMode(5, INPUT_PULLDOWN); // SPI0_CLK\n    pinMode(6, INPUT_PULLDOWN); // SPI0_PICO\n    pinMode(7, INPUT_PULLDOWN); // SPI0_POCI\n    pinMode(11, INPUT_PULLUP); // SDA\n    pinMode(12, INPUT_PULLUP); // SCL\n    pinMode(17, INPUT_PULLUP); // 17 SDPC uSD power control\n    pinMode(20, INPUT_PULLNONE); // aka PB_24, this is tied internally to PB_23 (aka Arduino pin \"17\") and also defaults to internal pulldown.\n\n    PowerSave.AONWakeClear();\n}\n\nvoid setup() {\n    // If you want serial debug messages, uncomment the following lines and others\n    // below, as desired.\n    // Open serial communications and wait for port to open:\n    // Serial.begin(115200);\n    // while (!Serial) {\n    //     ; // wait for serial port to connect. Needed for native USB port only\n    // }\n\n    PowerSave.begin(DEEPSLEEP_MODE);\n\n    if (TRUE == (PowerSave.DsleepWakeStatusGet())) {\n        DeepSleep_wakeup();\n    }\n\n    PowerSave.AONTimerDuration(0);\n\n    switch (DS_WAKEUP_SOURCE) {\n        case SET_DS_AON_TIMER_WAKEUP:\n            PowerSave.DS_AON_TIMER_WAKEUP();\n            PowerSave.AONTimerDuration(AON_TIMER_SLEEP_DURATION);\n            break;\n        case SET_DS_RTC_WAKEUP:\n            PowerSave.DS_RTC_WAKEUP();\n            PowerSave.RTCWakeSetup(DS_RTC_ALARM_DAY, DS_RTC_ALARM_HOUR, DS_RTC_ALARM_MIN, DS_RTC_ALARM_SEC);\n            break;\n        case SET_AON_GPIO_WAKEUP_PA12:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA12();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA13:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA13();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA14:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA14();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA15:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA15();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA16:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA16();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA17:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA17();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA18:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA18();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA19:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA19();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA20:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA20();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA21:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA21();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA25:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA25();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA26:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA26();\n            break;\n        default:\n            printf(\"Unknown wakeup source.    \\r\\n\");\n        break;\n    }\n\n    PowerSave.enable();\n}\n\nvoid loop() {\n    delay(1000);\n}\n\nvoid readSensor()\n{\n    pinMode(0, INPUT); // LOG RX, can backpower the CP2102\n    pinMode(1, OUTPUT); // LOG TX, can backpower the CP2102\n\n    pinMode(11, OUTPUT); // SDA\n    pinMode(12, OUTPUT); // SCL\n\n    pinMode(17, OUTPUT); // 17 SDPC uSD power control\n    digitalWrite(17, LOW); // uSD power GND = ON\n\n    Serial.begin(115200);\n\n    cout &lt;&lt; F(\"SdFat version: \") &lt;&lt; SD_FAT_VERSION_STR &lt;&lt; endl;\n    printConfig(SD_CONFIG);\nuint32_t t = millis();\n      if (!sd.cardBegin(SD_CONFIG)) {\n    cout &lt;&lt; F(\n           \"\\nSD initialization failed.\\n\"\n           \"Do not reformat the card!\\n\"\n           \"Is the card correctly inserted?\\n\"\n           \"Is there a wiring/soldering problem?\\n\");\n    if (isSpi(SD_CONFIG)) {\n      cout &lt;&lt; F(\n           \"Is SD_CS_PIN set to the correct value?\\n\"\n           \"Does another SPI device need to be disabled?\\n\"\n           );\n    }\n    errorPrint();\n    return;\n  }\n\n    t = millis() - t;\n  cout &lt;&lt; F(\"init time: \") &lt;&lt; dec &lt;&lt; t &lt;&lt; \" ms\" &lt;&lt; endl;\n\n  if (!sd.card()-&gt;readCID(&amp;cid) ||\n      !sd.card()-&gt;readCSD(&amp;csd) ||\n      !sd.card()-&gt;readOCR(&amp;ocr) ||\n      !sd.card()-&gt;readSCR(&amp;scr)) {\n    cout &lt;&lt; F(\"readInfo failed\\n\");\n    errorPrint();\n    return;\n  }\n  printCardType();\n  cout &lt;&lt; F(\"sdSpecVer: \") &lt;&lt; 0.01*scr.sdSpecVer() &lt;&lt; endl;\n  cout &lt;&lt; F(\"HighSpeedMode: \");\n  if (scr.sdSpecVer() &amp;&amp;\n    sd.card()-&gt;cardCMD6(0X00FFFFFF, cmd6Data) &amp;&amp; (2 &amp; cmd6Data[13])) {\n    cout &lt;&lt; F(\"true\\n\");\n  } else {\n    cout &lt;&lt; F(\"false\\n\");\n  }      \n  cidDmp();\n  csdDmp();\n  cout &lt;&lt; F(\"\\nOCR: \") &lt;&lt; uppercase &lt;&lt; showbase;\n  cout &lt;&lt; hex &lt;&lt; ocr &lt;&lt; dec &lt;&lt; endl;\n  if (!mbrDmp()) {\n    return;\n  }\n  if (!sd.volumeBegin()) {\n    cout &lt;&lt; F(\"\\nvolumeBegin failed. Is the card formatted?\\n\");\n    errorPrint();\n    return;\n  }\n  dmpVol();\n\n\n\n\n    Wire.begin();\n    Wire.setClock(400000); //Increase to fast I2C speed!\n    if (mySensor.beginI2C() == false) //Begin communication over I2C\n    {\n        printf(\"The sensor did not respond. Please check wiring.\");\n        while(1); //Freeze\n    }\n\n    mySensor.setMode(MODE_FORCED); //Wake up sensor and take reading\n\n    while(mySensor.isMeasuring() == false) ; //Wait for sensor to start measurment\n    while(mySensor.isMeasuring() == true) ; //Hang out while sensor completes the reading    \n\n    humidity = mySensor.readFloatHumidity();\n    pressure = mySensor.readFloatPressure();\n    altitude = mySensor.readFloatAltitudeFeet();\n    temperature = mySensor.readTempF();\n\n    printf(\" Humidity: \");\n    printf(\"%d\", int(humidity));\n\n    printf(\" Pressure: \");\n    printf(\"%d\", int(pressure));\n\n    printf(\" Altitude: \");\n    printf(\"%d\", int(altitude));\n\n    printf(\" Temperature: \");\n    printf(\"%d\", int(temperature));\n\n    mySensor.setMode(MODE_SLEEP); //Sleep for now\n\n    Wire.end();\n\n    logDataToSd();\n}\n\n//------------------------------------------------------------------------------\nvoid cidDmp() {\n  cout &lt;&lt; F(\"\\nManufacturer ID: \");\n  cout &lt;&lt; uppercase &lt;&lt; showbase &lt;&lt; hex &lt;&lt; int(cid.mid) &lt;&lt; dec &lt;&lt; endl;\n  cout &lt;&lt; F(\"OEM ID: \") &lt;&lt; cid.oid[0] &lt;&lt; cid.oid[1] &lt;&lt; endl;\n  cout &lt;&lt; F(\"Product: \");\n  for (uint8_t i = 0; i &lt; 5; i++) {\n    cout &lt;&lt; cid.pnm[i];\n  }\n  cout &lt;&lt; F(\"\\nRevision: \") &lt;&lt; cid.prvN() &lt;&lt; '.' &lt;&lt; cid.prvM() &lt;&lt; endl;\n  cout &lt;&lt; F(\"Serial number: \") &lt;&lt; hex &lt;&lt; cid.psn() &lt;&lt; dec &lt;&lt; endl;\n  cout &lt;&lt; F(\"Manufacturing date: \");\n  cout &lt;&lt; cid.mdtMonth() &lt;&lt; '/' &lt;&lt; cid.mdtYear() &lt;&lt; endl;\n  cout &lt;&lt; endl;\n}\n//------------------------------------------------------------------------------\nvoid clearSerialInput() {\n  uint32_t m = micros();\n  do {\n    if (Serial.read() &gt;= 0) {\n      m = micros();\n    }\n  } while (micros() - m &lt; 10000);\n}\n//------------------------------------------------------------------------------\nvoid csdDmp() {\n  eraseSize = csd.eraseSize();\n  cout &lt;&lt; F(\"cardSize: \") &lt;&lt; 0.000512 * csd.capacity();\n  cout &lt;&lt; F(\" MB (MB = 1,000,000 bytes)\\n\");\n\n\n  cout &lt;&lt; F(\"flashEraseSize: \") &lt;&lt; int(eraseSize) &lt;&lt; F(\" blocks\\n\");\n  cout &lt;&lt; F(\"eraseSingleBlock: \");\n  if (csd.eraseSingleBlock()) {\n    cout &lt;&lt; F(\"true\\n\");\n  } else {\n    cout &lt;&lt; F(\"false\\n\");\n  }\n  cout &lt;&lt; F(\"dataAfterErase: \");\n  if (scr.dataAfterErase()) {\n    cout &lt;&lt; F(\"ones\\n\");\n  } else {\n    cout &lt;&lt; F(\"zeros\\n\");\n  }\n}\n//------------------------------------------------------------------------------\nvoid errorPrint() {\n  if (sd.sdErrorCode()) {\n    cout &lt;&lt; F(\"SD errorCode: \") &lt;&lt; hex &lt;&lt; showbase;\n    printSdErrorSymbol(&amp;Serial, sd.sdErrorCode());\n    cout &lt;&lt; F(\" = \") &lt;&lt; int(sd.sdErrorCode()) &lt;&lt; endl;\n    cout &lt;&lt; F(\"SD errorData = \") &lt;&lt; int(sd.sdErrorData()) &lt;&lt; dec &lt;&lt; endl;\n  }\n}\n//------------------------------------------------------------------------------\nbool mbrDmp() {\n  MbrSector_t mbr;\n  bool valid = true;\n  if (!sd.card()-&gt;readSector(0, (uint8_t*)&amp;mbr)) {\n    cout &lt;&lt; F(\"\\nread MBR failed.\\n\");\n    errorPrint();\n    return false;\n  }\n  cout &lt;&lt; F(\"\\nSD Partition Table\\n\");\n  cout &lt;&lt; F(\"part,boot,bgnCHS[3],type,endCHS[3],start,length\\n\");\n  for (uint8_t ip = 1; ip &lt; 5; ip++) {\n    MbrPart_t *pt = &amp;mbr.part[ip - 1];\n    if ((pt-&gt;boot != 0 &amp;&amp; pt-&gt;boot != 0X80) ||\n        getLe32(pt-&gt;relativeSectors) &gt; csd.capacity()) {\n      valid = false;\n    }\n    cout &lt;&lt; int(ip) &lt;&lt; ',' &lt;&lt; uppercase &lt;&lt; showbase &lt;&lt; hex;\n    cout &lt;&lt; int(pt-&gt;boot) &lt;&lt; ',';\n    for (int i = 0; i &lt; 3; i++ ) {\n      cout &lt;&lt; int(pt-&gt;beginCHS[i]) &lt;&lt; ',';\n    }\n    cout &lt;&lt; int(pt-&gt;type) &lt;&lt; ',';\n    for (int i = 0; i &lt; 3; i++ ) {\n      cout &lt;&lt; int(pt-&gt;endCHS[i]) &lt;&lt; ',';\n    }\n    cout &lt;&lt; dec &lt;&lt; getLe32(pt-&gt;relativeSectors) &lt;&lt; ',';\n    cout &lt;&lt; getLe32(pt-&gt;totalSectors) &lt;&lt; endl;\n  }\n  if (!valid) {\n    cout &lt;&lt; F(\"\\nMBR not valid, assuming Super Floppy format.\\n\");\n  }\n  return true;\n}\n//------------------------------------------------------------------------------\nvoid dmpVol() {\n  cout &lt;&lt; F(\"\\nScanning FAT, please wait.\\n\");\n  int32_t freeClusterCount = sd.freeClusterCount();\n  if (sd.fatType() &lt;= 32) {\n    cout &lt;&lt; F(\"\\nVolume is FAT\") &lt;&lt; int(sd.fatType()) &lt;&lt; endl;\n  } else {\n    cout &lt;&lt; F(\"\\nVolume is exFAT\\n\");\n  }\n  cout &lt;&lt; F(\"sectorsPerCluster: \") &lt;&lt; sd.sectorsPerCluster() &lt;&lt; endl;\n  cout &lt;&lt; F(\"fatStartSector:    \") &lt;&lt; sd.fatStartSector() &lt;&lt; endl;\n  cout &lt;&lt; F(\"dataStartSector:   \") &lt;&lt; sd.dataStartSector() &lt;&lt; endl;\n  cout &lt;&lt; F(\"clusterCount:      \") &lt;&lt; sd.clusterCount() &lt;&lt; endl;  \n  cout &lt;&lt; F(\"freeClusterCount:  \");\n  if (freeClusterCount &gt;= 0) {\n    cout &lt;&lt; freeClusterCount &lt;&lt; endl;\n  } else {\n    cout &lt;&lt; F(\"failed\\n\");\n    errorPrint();    \n  }\n}\n//------------------------------------------------------------------------------\nvoid printCardType() {\n  cout &lt;&lt; F(\"\\nCard type: \");\n  switch (sd.card()-&gt;type()) {\n    case SD_CARD_TYPE_SD1:\n      cout &lt;&lt; F(\"SD1\\n\");\n      break;\n    case SD_CARD_TYPE_SD2:\n      cout &lt;&lt; F(\"SD2\\n\");\n      break;\n    case SD_CARD_TYPE_SDHC:\n      if (csd.capacity() &lt; 70000000) {\n        cout &lt;&lt; F(\"SDHC\\n\");\n      } else {\n        cout &lt;&lt; F(\"SDXC\\n\");\n      }\n      break;\n    default:\n      cout &lt;&lt; F(\"Unknown\\n\");\n  }\n}\n//------------------------------------------------------------------------------\nvoid printConfig(SdSpiConfig config) {\n  if (DISABLE_CS_PIN &lt; 0) {\n    cout &lt;&lt; F(\n           \"\\nAssuming the SD is the only SPI device.\\n\"\n           \"Edit DISABLE_CS_PIN to disable an SPI device.\\n\");\n  } else {\n    cout &lt;&lt; F(\"\\nDisabling SPI device on pin \");\n    cout &lt;&lt; int(DISABLE_CS_PIN) &lt;&lt; endl;\n    pinMode(DISABLE_CS_PIN, OUTPUT);\n    digitalWrite(DISABLE_CS_PIN, HIGH);\n  }\n  cout &lt;&lt; F(\"\\nAssuming the SD chip select pin is: \") &lt;&lt; int(config.csPin);\n  cout &lt;&lt; F(\"\\nEdit SD_CS_PIN to change the SD chip select pin.\\n\");\n}\n//------------------------------------------------------------------------------\nvoid printConfig(SdioConfig config) {\n  (void)config;\n  cout &lt;&lt; F(\"Assuming an SDIO interface.\\n\");\n}\n\n//------------------------------------------------------------------------------\nvoid logDataToSd()\n{\n  // open the file. note that only one file can be open at a time,\n  // so you have to close this one before opening another.\n  myFile = sd.open(\"log.txt\", FILE_WRITE);\n\n  // if the file opened okay, write to it:\n  if (myFile) {\n    Serial.print(\"Writing to log.txt...\");\n\n    myFile.print(\"Humidity:\");\n    myFile.print(humidity);\n    myFile.print(\",Pressure:\");\n    myFile.print(pressure);\n    myFile.print(\",Altitude:\");\n    myFile.print(altitude);\n    myFile.print(\",Temperature:\");\n    myFile.println(temperature);\n\n    // close the file:\n    myFile.close();\n    Serial.println(\"done.\");\n  } else {\n    // if the file didn't open, print an error:\n    Serial.println(\"error opening log.txt\");\n  }\n\n  // re-open the file for reading:\n  myFile = sd.open(\"log.txt\");\n  if (myFile) {\n    Serial.println(\"log.txt:\");\n\n\n    // read from the file until there's nothing else in it:\n    while (myFile.available()) {\n      Serial.write(myFile.read());\n    }\n    // close the file:\n    myFile.close();\n  } else {\n    // if the file didn't open, print an error:\n    Serial.println(\"error opening log.txt\");\n  }\n}\n</code></pre> <p>Open the Arduino Serial Monitor at 115200 to view the output. You should see the NORA-W306 wake up, read the sensor data, user LED blink, print the data as an integer through the serial terminal, write to a file, and then close the file. For verification, the code will also re-open the file, print the contents of the file, and then close the file again. This is a good time to verify if the sensor readings are being written at the end of the file.</p> Arduino Output from the NORA-W306's Deep Sleep and Datalogging Example <p>Tip</p> <p>For users that need to comment out the lines of code to re-open the file and read the sensor data, you will just need to add a multiline comment (i.e. /* and <code>*/</code>) around the following lines of code as shown below.</p> <pre><code>  // re-open the file for reading:\n  /*myFile = sd.open(\"log.txt\");\n  if (myFile) {\n    Serial.println(\"log.txt:\");\n\n\n    // read from the file until there's nothing else in it:\n    while (myFile.available()) {\n      Serial.write(myFile.read());\n    }\n    // close the file:\n    myFile.close();\n  } else {\n    // if the file didn't open, print an error:\n    Serial.println(\"error opening log.txt\");\n  }*/\n</code></pre> <p>Note</p> <p>The sensor output in the Arduino Serial Monitor displayed the sensor reading as integers. When writing to the file, the sensor readings were floats.</p> <p>For those that want to verify through a text editor, remove the USB cable from the NORA-W306. Then remove the microSD card from the board. Connect the microSD card to your computer. Using a text editor, open the file labeled as log.txt. You should see the sensor readings that were logged earlier. You may have an additional line of comma separated values written to the file before removing power from the board.</p> Log File Opened Through Text Editor Displaying Sensor Readings <p>For those interested in viewing the current consumption, cut the MEAS jumper on the back of the NORA-W306. Solder a 1x2 breakaway male header to the board. Then connect it to a multimeter to measure the current consumption. Using a LiPo battery will bring down the current consumption since the LiPo battery charger, CHG LED, and CP2102 USB-to-serial converter are not being powered. Try disabling the power LED jumpers on the NORA-W306 and BME280. You can take it a step further by also disabling power to the WS2812 by cutting the JP3 jumper.</p> Fritzing Diagrams with Multimeter Connected to NORA-W306's MEAS Jumper"},{"location":"arduino_example_9_lipo_fuel_gauge/","title":"Example 9 - MAX17048 LiPo Fuel Gauge","text":"<p>In this example, we will measure the LiPo battery's capacity using the built-in MAX17048 LiPo Fuel Gauge.</p>"},{"location":"arduino_example_9_lipo_fuel_gauge/#hardware-hookup","title":"Hardware Hookup","text":"<p>We recommend connecting a single cell LiPo battery to the 2-pin JST style connector. If you have not already, connect a compatible single cell, LiPo battery to the board.</p> Battery Connected <p>When ready, connect the board to your computer with the USB C cable.</p>"},{"location":"arduino_example_9_lipo_fuel_gauge/#installing-the-arduino-library","title":"Installing the Arduino Library","text":"<p>First, you'll need to download and install the SparkFun MAX1704x Fuel Gauge Arduino Library. You can install this library automatically in the Arduino IDE's Library Manager by searching for \"SparkFun MAX1704x Fuel Gauge\". Or you can manually download it from the GitHub repository.</p> Download the SparkFun MAX1704x Fuel Gauge Arduino Library (ZIP)"},{"location":"arduino_example_9_lipo_fuel_gauge/#arduino-code","title":"Arduino Code","text":"<p>In this example, we will be checking a single cell LiPo battery's voltage and the state of charge using the MAX17048. The output will be sent to the Serial Monitor.</p> <p>From the menu, select the following: File &gt; Examples &gt; SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library &gt; Example1_Simple. Comment out the default instance for the MAX17043 and uncomment the line for the MAX17048.</p> <pre><code>//SFE_MAX1704X lipo; // Defaults to the MAX17043\n\n//SFE_MAX1704X lipo(MAX1704X_MAX17043); // Create a MAX17043\n//SFE_MAX1704X lipo(MAX1704X_MAX17044); // Create a MAX17044\nSFE_MAX1704X lipo(MAX1704X_MAX17048); // Create a MAX17048\n//SFE_MAX1704X lipo(MAX1704X_MAX17049); // Create a MAX17049\n</code></pre> <p>Or you can copy and paste the following code in the Arduino IDE. Select your Board (in this case the SparkFun Thing Plus NORA-W306 (RTL8720DF)), and associated COM port (in this case COM13). Then hit the upload button.</p> <pre><code>/******************************************************************************\nExample1_Simple\nBy: Paul Clark\nDate: October 23rd 2020\n\nBased extensively on:\nMAX17043_Simple_Serial.cpp\nSparkFun MAX17043 Example Code\nJim Lindblom @ SparkFun Electronics\nOriginal Creation Date: June 22, 2015\n\nThis file demonstrates the simple API of the SparkFun MAX17043 Arduino library.\n\nThis example will print the gauge's voltage and state-of-charge (SOC) readings\nto Serial (115200 baud)\n\nThis code is released under the MIT license.\n\nDistributed as-is; no warranty is given.\n******************************************************************************/\n\n#include &lt;Wire.h&gt; // Needed for I2C\n\n#include &lt;SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library.h&gt; // Click here to get the library: http://librarymanager/All#SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library\n\n//SFE_MAX1704X lipo; // Defaults to the MAX17043\n\n//SFE_MAX1704X lipo(MAX1704X_MAX17043); // Create a MAX17043\n//SFE_MAX1704X lipo(MAX1704X_MAX17044); // Create a MAX17044\nSFE_MAX1704X lipo(MAX1704X_MAX17048); // Create a MAX17048\n//SFE_MAX1704X lipo(MAX1704X_MAX17049); // Create a MAX17049\n\ndouble voltage = 0; // Variable to keep track of LiPo voltage\ndouble soc = 0; // Variable to keep track of LiPo state-of-charge (SOC)\nbool alert; // Variable to keep track of whether alert has been triggered\n\nvoid setup()\n{\n    Serial.begin(115200); // Start serial, to output debug data\n  while (!Serial)\n    ; //Wait for user to open terminal\n  Serial.println(F(\"MAX17043 Example\"));\n\n  Wire.begin();\n\n  lipo.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial\n\n  // Set up the MAX17043 LiPo fuel gauge:\n  if (lipo.begin() == false) // Connect to the MAX17043 using the default wire port\n  {\n    Serial.println(F(\"MAX17043 not detected. Please check wiring. Freezing.\"));\n    while (1)\n      ;\n  }\n\n    // Quick start restarts the MAX17043 in hopes of getting a more accurate\n    // guess for the SOC.\n    lipo.quickStart();\n\n    // We can set an interrupt to alert when the battery SoC gets too low.\n    // We can alert at anywhere between 1% - 32%:\n    lipo.setThreshold(20); // Set alert threshold to 20%.\n}\n\nvoid loop()\n{\n  // lipo.getVoltage() returns a voltage value (e.g. 3.93)\n  voltage = lipo.getVoltage();\n  // lipo.getSOC() returns the estimated state of charge (e.g. 79%)\n  soc = lipo.getSOC();\n  // lipo.getAlert() returns a 0 or 1 (0=alert not triggered)\n  alert = lipo.getAlert();\n\n  // Print the variables:\n  Serial.print(\"Voltage: \");\n  Serial.print(voltage);  // Print the battery voltage\n  Serial.println(\" V\");\n\n  Serial.print(\"Percentage: \");\n  Serial.print(soc); // Print the battery state of charge\n  Serial.println(\" %\");\n\n  Serial.print(\"Alert: \");\n  Serial.println(alert);\n  Serial.println();\n\n  delay(500);\n}\n</code></pre> <p>Open the Arduino Serial Monitor and set it to 115200 baud to view the serial output. You should see the voltage, battery percent, alert flag, and several more readings. In this case, the single cell LiPo battery that was connected to the IC was fully charged and at about 4.10V.</p> Arduino Output Showing the LiPo Battery's Capacity <p>But wait! If you looked closely at the circuit of the SparkFun Thing Plus NORA-W306, there is also a charge circuit built in. Try closing out the Arduino Serial Monitor, disconnecting the USB, and disconnecting the LiPo battery. Then reinsert the LiPo battery, connect the USB cable, and reopen the Arduino Serial Monitor. The IC will recalculate everything. In the image below, the voltage is a bit misleading since the charge IC is charging the LiPo battery and may not be the true representation of the LiPo battery's voltage. The remaining charge was closer to what was expected.</p> Arduino Output Showing the LiPo Battery's Capacity <p>Note</p> <p>For development boards that have a built in charge circuit and fuel gauge, you may want to consider using a display to view the LiPo battery's true voltage and remaining charge. Otherwise, you could use a multimeter to measure the LiPo battery's voltage when a USB cable is not plugged in. Below is an example that uses the Qwiic Micro OLED to display the LiPo battery's voltage and remaining charge since the SparkFun Thing Plus NORA-W306 includes a built in charge circuit and fuel gauge (MAX17048). Just make sure to adjust the code for your fuel gauge and display.</p> <p> LiPo Fuel Gauge Monitoring LiPo Battery and Displaying Battery Capacity on Qwiic Micro OLED </p>"},{"location":"arduino_library/","title":"Installing the Arduino Library","text":"<p>To take advantage of a few of the built-in components on the board, you will need to install a Arduino Library. Of course, you may need additional Arduino Libraries depending on what you connect to the development board. At a minimum, you will need the following listed below to take advantage of the built-in LiPo Fuel Gauge (MAX17048).</p>"},{"location":"arduino_library/#sparkfun-max1704x-fuel-gauge-arduino-library","title":"SparkFun MAX1704x Fuel Gauge Arduino Library","text":"<p>SparkFun has written a library to work with the LiPo Fuel Gauge - MAX17048 that is built into the SparkFun Thing Plus NORA-W306. You can obtain this library through the Arduino Library Manager by searching for \"SparkFun MAX1704x Fuel Gauge\". Find the one written by SparkFun Electronics and install the latest version. Users who prefer to manually install the library can get it from the  GitHub Repository or download the .ZIP by clicking the button below:</p> SparkFun MAX1704x Fuel Gauge Arduino Library (ZIP)"},{"location":"arduino_library/#sdfat-arduino-library","title":"SdFat Arduino Library","text":"<p>Bill Greiman has written a library for memory cards formatted to FAT16/FAT32 exFAT. We used this Arduino Library instead of the ones that were listed in the libraries included with the AmebaD. You can obtain this library through the Arduino Library Manager by searching for \"sdfat\". Find the one written by Bill Greiman and install the latest version. Users who prefer to manually install the library can get it from the GitHub Repository or download the .ZIP by clicking the button below:</p> Bill Greiman's SdFat Arduino Library (ZIP) <p>Note</p> <p>At the time of writing, SdFat by Bill Greiman v2.2.3 worked with the SparkFun Thing Plus - NORA-W306.</p> <p>Note</p> <p>We recommend using some of the built-in libraries for the u-blox NORA-W306 as well after installing the board add-ons: File &gt; Examples &gt; Examples for SparkFun Thing Plus NORA-W306 (RTL8720DF) . Certain examples like the AmebaWS2812B were written specifically for the NORA-W306 architecture.</p> <p> More Arduino Examples! </p>"},{"location":"hard_copy/","title":"Hard copy","text":"<p>Need to download or print our hookup guide?</p> <ul> <li>Print  (Single-Page View)<ul> <li>To save as a <code>*.pdf</code> file, select the Printer or Destination labeled Save as PDF. (Instructions will vary based on the browser)</li> </ul> </li> </ul>"},{"location":"hardware_hookup/","title":"Hardware Hookup","text":"<p>At a minimum, you will need to plug in the USB C cable to the SparkFun Thing Plus NORA-W306 to power and program the board.</p> USB Cable inserted into Thing Plus NORA-W306"},{"location":"hardware_hookup/#single-cell-lipo-battery","title":"Single Cell LiPo Battery","text":"<p>Battery Polarity</p> <p>Please make sure that you use one of our recommended Lithium Ion batteries. Some batteries use the same JST connector as ours but have the opposite polarity. Connecting one of these to your SparkFun Thing Plus NORA-W306 will destroy it. If you are going to use your own battery, it is up to you to ensure it has the correct polarity.</p> <p>For remote applications, you can connect a standard single cell LiPo battery. The SparkFun Thing Plus NORA-W306 has a built-in charger too which will charge your battery at 500mA when a USB-C is connected. Please make sure your battery capacity is at least 500mAh (0.5Ah); bad things will happen if you try to charge smaller batteries using the board's default charge rate of 500mA. Of course, you can adjust the charge rate with the 3-way jumper on the back of the board. The yellow CHG charging LED will light up while the battery is charging and will turn off once charging is complete.</p> Battery Connected <p>The MCP73831 charge IC on the board is used on a few SparkFun products. For more information about the CHG status LED, we recommend taking look at the Hardware Overview. We also recommend taking a look at this tutorial for Single Cell LiPo Battery Care.</p> <ul> <li> <p> </p> <p> Single Cell LiPo Battery Care </p> </li> </ul>"},{"location":"hardware_hookup/#inserting-a-microsd-card","title":"Inserting a MicroSD Card","text":"<p>For those that need to store data, you can add a microSD card to your application. You will just need to insert a microSD card with the metal contacts facing the board and into the socket on the back. Compared to other microSD cards sockets in sparkFun's storefront, this will not have a click to lock the memory card in place. Just make sure to fully insert the memory card.</p> MicroSD Card in Socket <p>You should only insert or remove the SD card while the power is turned off or disconnected. Removing the card while the SparkFun Thing Plus NORA-W306 is powered will almost certainly corrupt your data.</p>"},{"location":"hardware_hookup/#connecting-via-qwiic","title":"Connecting via Qwiic","text":"<p>For users that want to connect a Qwiic-enabled device, you will simply need to insert a cable between the Qwiic connectors. Then insert a USB cable between the microcontroller and your computer to power and program.</p> Qwiic-enabled Device Connected to Thing Plus NORA-W306"},{"location":"hardware_hookup/#connecting-via-pth","title":"Connecting via PTH","text":"<p>For temporary connections to the PTHs, you could use IC hooks to test out the pins. However, you'll need to solder headers or wires of your choice to the board for a secure connection. You can choose between a combination of header pins and jumper wires, or stripping wire and soldering the wire directly to the board.</p> <ul> <li> <p> </p> <p> How to Solder: Through Hole Soldering </p> </li> </ul> <ul> <li> <p> </p> <p> Working with Wire </p> </li> </ul>"},{"location":"hardware_overview/","title":"Hardware Overview","text":"<p>In this section, we will highlight the hardware and pins that are broken out on the SparkFun Thing Plus NORA-W306. For more information, check out our Resources and Going Further for the u-blox NORA-W306 module or Realtek RTL8720DF that is contained within the module.</p> Top View Bottom View"},{"location":"hardware_overview/#power","title":"Power","text":"<p>There are a variety of power and power-related nets broken out to connectors and through hole pads. Power is regulated down to 3.3V for the NORA-W306 so the logic level is 3.3V. There are Schottky diode and transistors to safely select voltage from the USB or LiPo battery. This avoids any conflicting voltages between the two sources.</p> <ul> <li>VU or VUSB \u2014 The V_BUS net is connected to the USB Type C connector and the VU/VUSB PTH. You can use 5V from a USB port by connecting to the USB Type C connector or connecting power to the VBUS PTH. Make sure that power you provide to this pin does not exceed 6 volts. Power is regulated down with the XC6222 3.3V/700mA voltage regulator. The USB Type C connector is also used to upload code to your processor, send serial data to a terminal window, or charging the LiPo battery. Of course for portable power, you could connect a USB battery as an alternative to using a LiPo battery.</li> <li>VB \u2014  The V_BATT net is connected to the 2-pin JST style connector, VB PTH, and the NORA-W306's MEAS pin. For portable applications, you can connect a nominal 3.7V single cell, LiPo battery to the 2-pin JST style connector. This pin is also connected to the MCP73831 charge IC to safely charge the LiPo battery to its maximum voltage of about 4.2V. We recommend connecting only LiPo batteries to the VBAT net to power the board. Of course, you can power a separate device through the VBAT PTH pin. Power is regulated down with the XC6222 3.3V/700mA voltage regulator.</li> <li>3V or 3V3 \u2014 The 3.3V net is labeled as 3V or 3V3. You can apply power to the board if you have a regulated voltage of 3.3V. Otherwise, you could power a separate device through the 3V3 PTH pin. This is also connected to the Qwiic connector's 3.3V pin to power Qwiic enabled devices.</li> <li>EN \u2014 The 3.3V voltage regulator's EN pin is labeled as EN. Pulling this pin low will disable the 3.3V voltage regulator.</li> <li>G or GND \u2014 Of course, is the common, ground voltage (0V reference) for the system.</li> </ul> Power, Ground, and Connectors Highlighted(Top &amp; Bottom View) <p>Note</p> <p>You will notice the pads of the SWD pins are also highlighted! 3.3V and ground are also connected to these pads. Users can easily access these pins using a SWD header and cable. Of course, you could also solder wire to those pads if you needed another way to connect to the traces.</p> <p>Tip</p> <p>To complement the module's low-power options, we've optimized components and added the ability to depower all subsystems to conserve as much power as possible for remote battery-powered applications. Without a battery attached or charging, and cutting the power to WS2812 (i.e. jumper JP3); the current draw was as low as 14\u00b5A in low power mode! Amazing! Under normal conditions, we measured the current draw as low as 30mA.</p> <p>Let's compare the Thing Plus ESP32 (USB-C) against the Thing Plus NORA-W306. The power LED jumper was cut on the Thing Plus ESP32. A microSD card was inserted in the microSD card socket (which does not have a way to turn off power through a GPIO) and the board was powered via a single cell LiPo battery. The current draw was 884\u00b5A in deep sleep mode while it was 40mA when awake.</p> <p>For the Thing Plus NORA-W306, we cut the power LED and WS28112 LED jumpers. The SDPC (microSD Power Control) jumper was modified so power to the microSD card can be controlled through GPIO 17. A microSD card was inserted in the microSD card socket. With the MEAS jumper cut, a multimeter (set to measure current) was connected to monitor the current draw. Power was also provided via a single cell LiPo battery. The current draw was 115\u00b5A in deep sleep mode while it was 21mA when awake.</p> <p>For more information, check out the demo video below with current draw for the board in low power mode!</p> <p> </p>"},{"location":"hardware_overview/#lipo-charge-circuit","title":"LiPo Charge Circuit","text":"<p>The board includes the MCP73831 LiPo charger IC (the little black IC with 5 pins highlighted) to safely charge a single cell, LiPo battery. In this case, the charge rate is set to a default rate of 500mA. Cutting the trace on the back while adding a solder jumper between the middle pad and the pad labeled as 100mA will set the charge rate to 100mA. The on-board LED (not highlighted) labeled as CHG can be used to get an indication of the charge status of your battery.</p> 2-pin JST Style Connector, LiPo Charger IC, and VBATT PTH Highlighted(Top View) <p>Note</p> <p>For more information on proper handling of LiPo batteries, check out the tutorial on Single Cell LiPo Battery Care.</p> <ul> <li> <p> </p> <p> Single Cell LiPo Battery Care </p> </li> </ul> <p> </p>"},{"location":"hardware_overview/#gpio","title":"GPIO","text":"<p>The SparkFun Thing Plus - NORA-W306 breaks out the GPIO pins to plated through hole pads on the edge of the board using the Thing Plus/Feather Form Factor. Each of the pins on the edge of the board are tired to various components on the board. Check below for more information on each connection!</p> GPIO Pins Highlighted(Top &amp; Bottom View) <p>Note that the pin label might have additional functionality that may not be apparent from the silkscreen. Below is a graphical datasheet of the SparkFun Thing Plus - NORA-W306 that highlights the additional functionality.</p> Graphical Datasheet <p>Note</p> <p>While the u-blox integration manual may have pins highlighted to show additional functionality, there are some that are not supported in the Realtek's Arduino core. Some of these features that are not supported in the Arduino core include SDIO, I2S, IR, and RTC.</p>"},{"location":"hardware_overview/#swd","title":"SWD","text":"<p>For advanced users, the SWD pins are broken out on the 2x5 header on the back of the board. Note that this is not populated so you will need to solder a compatible header, 2x5 SWD cable, and compatible JTAG programmer to connect. These pins are also connected to the edge of the board.</p> SWD Pins Highlighted <p>Note</p> <p>Pin <code>10</code> is tied to the SWD Data pad and <code>A0</code> is tied to SWD CLK pad on the back of the board.</p>"},{"location":"hardware_overview/#reset-and-boot-buttons","title":"Reset and Boot Buttons","text":"<p>Each board includes a RESET and BOOT button. There is an additional reset PTH next to the reset button. Hit the reset button to restart the NORA-W306. To manually place the NORA-W306 into boot mode, hold down the BOOT button while pressing the RESET button momentarily and then release the BOOT button.</p> Reset and Boot Pins and Buttons Highlighted(Top &amp; Bottom View) <p>Note</p> <p>The BOOT button is also connected to pin 0 (TX). The datasheet refers to this pin as the CHIP_EN.</p> <p>Note</p> <p>You will notice a pad of the SWD is also highlighted. The reset pin is connected to this pad. Users can easily access these pins using a SWD header and cable. Of course, you could also solder wire to those pads if you needed another way to connect to the traces.</p>"},{"location":"hardware_overview/#user-button","title":"User Button","text":"<p>The board also includes a user button that is connected pin <code>2</code>.</p> Reset &amp; Boot Pins and Buttons Highlighted(Top &amp; Bottom View) <p>Note</p> <p>When defining the pin for the user button, make sure to use an internal pull-up resistor so that the button is not floating.</p> <p>Tip</p> <p>Need a bigger button? Users can connect pin 2 on the edge of the board to an external button!</p>"},{"location":"hardware_overview/#interrupts","title":"Interrupts","text":"<p>Speaking of buttons, all GPIOs can also be set as interrupts!</p> Interrupt Pins Highlighted(Top &amp; Bottom View)"},{"location":"hardware_overview/#uart","title":"UART","text":"<p>There are two UARTs. The primary hardware UART (UART0) is connected to the USB-to-serial converter. The secondary hardware UART (UART1) is broken out to the edge of the board. We recommend connecting a UART device to the secondary hardware UART to avoid any bus contention with the CP2102N.</p> UARTs Highlighted(Top &amp; Bottom View)"},{"location":"hardware_overview/#cp2102n-usb-to-serial-converter","title":"CP2102N USB-to-Serial Converter","text":"<p>The board includes the CP2102N USB-to-Serial converter. This is used for serial programming or communicating with a serial terminal. The CP2102N is connected to the NORA-W306's primary hardware UART (UART0): TX pin is connected to pin <code>0</code> (RX0) while and RX pin is connected to pin <code>1</code> (TX0).</p> USB-to-Serial Converter, USB, and UART0 Highlighted(Top &amp; Bottom View)"},{"location":"hardware_overview/#qwiic-and-i2c","title":"Qwiic and I<sup>2</sup>C","text":"<p>The board includes one horizontal Qwiic connector on the board. These pins are connected to the primary I<sup>2</sup>C bus and power (e.g. 3.3V and GND) allowing you to easily add a Qwiic-enabled device to your application. The I<sup>2</sup>C data and clock lines are also tied to 2.2k\u03a9 pull-up resistors. The I<sup>2</sup>C SCL pin is connected to <code>12</code>. The I<sup>2</sup>C SDA is connected to <code>11</code>.</p> I<sup>2</sup>C and Qwiic Connector Highlighted(Top &amp; Bottom View)"},{"location":"hardware_overview/#lipo-fuel-gauge-max17048","title":"LiPo Fuel Gauge - MAX17048","text":"<p>Built into the board is also the single cell LiPo Fuel Gauge, specifically the MAX17408. The 7-bit, unshifted address of the MAX17048 is 0x36. The address becomes 0x6C for write and 0x6D for read.  </p> LiPo Fuel Gauge - MAX17048 Highlighted(Top View)"},{"location":"hardware_overview/#spi","title":"SPI","text":"<p>There are two SPI ports available. The primary SPI pins (SPI0) is broken out as:  <code>5</code> (SPI0_SCK), <code>6</code> (SPI0_PICO), <code>7</code> (SPI0_POCI), and <code>4</code> (SPI0_CS). These are also connected to the microSD card that is populated on the back. The secondary SPI pins (SPI1) is broken out as: <code>16</code> (SPI1_SCK), <code>14</code> (SPI1_PICO), <code>13</code> (SPI1_POCI), and <code>15</code> (SPI1_CS)</p> SPI Pins Highlighted(Top &amp; Bottom View) <p>Note</p> <p>Pin <code>14</code> is also connected to the addressable LED. The Realtek Arduino Core needed to use this specific SPI pin to control WS2812. Users can disable the addressable LED by cutting JP1 on the back of the board.</p>"},{"location":"hardware_overview/#microsd-card-socket","title":"MicroSD Card Socket","text":"<p>Built into the board is a microSD card socket to log data. As explained in the SPI section, the data lines are connected to the primary SPI pins (SPI0). One special feature that is different from other Thing Plus boards is the transistor to toggle power to the microSD card socket. By default, it is always on. For users that want to conserve power, you can cut the jumper for the SDPC. You will then need to add a solder blob between the center pad and the pad that is labeled 17.</p> Micro SD Card, Transistor, and Power Enable Pin Highlighted(Top &amp; Bottom View)"},{"location":"hardware_overview/#pulse-width-modulation-pwm","title":"Pulse Width Modulation (PWM)","text":"<p>There are 12x PWM pins available: <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>11</code>, <code>12</code>, <code>13</code>, <code>14</code>, <code>17</code>, and <code>18</code>. Note that these are tied to other peripherals as well.</p> PWM Pins Highlighted(Top &amp; Bottom View)"},{"location":"hardware_overview/#analog","title":"Analog","text":"<p>There are 3x 12-bit analog pins available: <code>A0</code>, <code>A1</code>, and <code>A2</code>.</p> ADC Pins Highlighted(Top &amp; Bottom View)"},{"location":"hardware_overview/#leds","title":"LEDs","text":"<p>There are 4x LEDs populated on the board.</p> <ul> <li>PWR \u2014 The PWR LED lights up to indicate when there is a 3.3V available after power is regulated down from the USB connector or LiPo battery. This can be disabled by cutting the jumper labeled as PWR.</li> <li>CHG \u2014 The on-board yellow CHG LED can be used to get an indication of the charge status of your battery. Below is a table of other status indicators depending on the state of the charge IC. This can be disabled by cutting the jumper labeled as CHG.</li> <li>RGB IO14 \u2014 The RGB IO14 LED is an WS2812-2020 LED. Users can control this addressable RGB LED using pin <code>14</code>. This LED can be disconnected from the pin by cutting the jumper labeled as JP1. For users that are not using this LED and want to conserve power, the 3.3V net can also be disconnected as well by cutting the jumper labeled as JP3. For users that are interested in daisy chaining additional WS2812 LEDs, users can connect to the PTH labled as LD or LED D0.</li> <li>IO18 \u2014 The LED labeled as IO18 can be configured by the user and is connected to pin <code>18</code>. This can be disconnect from the pin by cutting the jumper labeled JP2.</li> </ul> Charge State LED status No Battery Floating (should be OFF, but may flicker) Shutdown Floating (should be OFF, but may flicker) Charging ON Charge Complete OFF LEDs and Connected PTHs Highlighted(Top &amp; Bottom View)"},{"location":"hardware_overview/#jumpers","title":"Jumpers","text":"<p>Note</p> <p>If this is your first time working with jumpers, check out the How to Work with Jumper Pads and PCB Traces tutorial for more information.</p> <p>There are a few jumper pads available on the bottom of the board.</p> <ul> <li>SHLD \u2014 This jumper connects the USB Type C connector's shield pin to GND. Cut this to isolate the USB Type C connector's shield pin. This is for advanced users that want to ground their board to their enclosure instead of the ground plane.</li> <li>MEAS \u2014 To enable measurements and determine how long your battery might last, we've added a NC (normally closed) jumper between the two MEAS PTH pins. By cutting this jumper, the voltage connecting to the 3.3V voltage regulator input is interrupted. Soldering in a male jumper or wires into the accompanying holes will give you the ability to insert a current meter and precisely monitor how much current your application is consuming.</li> <li>PWR \u2014 By default, this jumper is closed. Cut this trace to disable the power LED that is connected to 3.3V.</li> <li>CHG \u2014 By default, this jumper is closed. Cut this trace to disable the charge LED that is connected to the LiPo charge IC.</li> <li>LED_D0 \u2014 By default, this jumper is closed. Cut this trace to disable the WS2812 addressable RGB LED's output pin labeled as <code>D0</code>.</li> <li>JP1 \u2014 By default, this jumper is closed. Cut this trace to disable the WS2812 addressable RGB LED's input pin that is connected to pin <code>14</code>.</li> <li>JP2 \u2014 By default, this jumper is closed. Cut this trace to disable the user LED that is connected to pin <code>18</code>.</li> <li>JP3 \u2014 By default, this jumper is closed. Cut this trace to disable power connected to the WS2812 addressable LED's 3.3V pin.</li> <li>CUR \u2014 This three way jumper sets the charge IC's charge rate. By default, it's connected to the pad labeled 500 so the charge rate is set to 500mA. Cutting a trace and adding a solder jumper between the center pad and the pad labeled as 100 will set the charge rate to 100mA.</li> <li>I2C \u2014 By default, this three-pad jumper is closed and located on the bottom of the board. The three way jumper labeled I2C connect the two 2.2k\u03a9 pull-up resistors to the I<sup>2</sup>C data and clock lines. If multiple devices are connected to the bus with the pull-up resistors enabled, the parallel equivalent resistance will create too strong of a pull-up for the bus to operate correctly. As a general rule of thumb, disable all but one pair of pull-up resistors if multiple devices are connected to the bus.</li> <li>SDPC \u2014 By default, this jumper is closed and for the microSD card's power control circuit. Cut this trace on the GND/ON side to disable power to the microSD card's socket. For users that want to control the transistor via a GPIO, add a solder blob between the center pad and the pad that is labeled 17. Make sure to also define the pin in code to toggle power to the microSD card.</li> </ul> Jumpers Highlighted(Top &amp; Bottom View)"},{"location":"hardware_overview/#board-dimensions","title":"Board Dimensions","text":"<p>The board is 0.9\" x 2.3\" (22.86mm x 58.42mm) and uses the standard Thing+ footprint. There are 4x mounting holes by each corner of the board. You can use 4-40 standoffs to mount the board to a panel or enclosure.</p> Board Dimensions"},{"location":"installing_drivers/","title":"Installing the CP2102 USB Driver","text":"<p>Warning</p> <p>Make sure to manually install the driver for the CP2102N with the following instructions. The driver that Windows auto-installs will not work with the auto-reset circuit on the board and can cause serial uploads to fail.</p> <p>You will also need to install the SiLabs CP210X Driver, which can be found here: USB to UART Bridge VCP Driver.</p> Windows VCP Driver (ZIP) Mac OSX VCP Driver (ZIP) <p>Note</p> <p>If applicable, make sure you are using the proper driver files for your CPU architecture. This is usually indicated by a folder or file name with \"x86\" for 32-bit processors or \"x64\" for 64-bit processors.</p>"},{"location":"introduction/","title":"Introduction","text":"<p>The SparkFun Thing Plus - NORA-W306 is a Feather form-factor development board equipped with the u-blox NORA-W306 module. The module contains a Realtek RTL8720DF, which has an integrated single-chip low-power dual-band (2.4GHz and 5GHz) Wireless LAN (WLAN) and Bluetooth\u00ae Low Energy (BLE 5.3) communication microcontroller. It also consists of a dual processor core: Arm Cortex-M33 and Cortex-M23. To complement the module's low-power options, we've optimized components and added the ability to depower all subsystems to conserve as much power as possible for remote battery-powered applications.</p> <ul> <li> <p> </p> <p> SparkFun Thing Plus NORA-W306    WRL-21637    Purchase from SparkFun  </p> </li> </ul> <p>In this tutorial, we'll go over the hardware and how to hookup the development board to an Arduino. We will also go over a few Arduino examples to get started!</p>"},{"location":"introduction/#required-materials","title":"Required Materials","text":"<p>To follow along with this tutorial, you will need the following materials. You may not need everything though depending on what you have. Add it to your cart, read through the guide, and adjust the cart as necessary.</p> <ul> <li> <p> </p> <p> Reversible USB A to C Cable - 0.8m    CAB-15425 </p> </li> </ul> <ul> <li> <p> </p> <p> SparkFun Thing Plus NORA-W306    WRL-21637 </p> </li> </ul> <ul> <li> <p> </p> <p> microSD Card - 1GB (Class 4)    COM-15107 </p> </li> </ul> <ul> <li> <p> </p> <p> SparkFun Micro OLED Breakout (Qwiic)    SEN-22495 </p> </li> </ul> <ul> <li> <p> </p> <p> Flexible Qwiic Cable - 50mm    PRT-17260 </p> </li> </ul> <p>Note</p> <p>Make sure that you have a microSD card reader or adapter as well to read the contents saved on the memory card.</p> <p> MicroSD Card Adapters"},{"location":"introduction/#tools-optional","title":"Tools (Optional)","text":"<p>You will need a soldering iron, solder, and general soldering accessories for a secure connection when using the plated through holes. For users that are measuring the current draw, you may want to consider grabbing a digital multimeter or a USB C cable that is able to display the current draw.</p> <ul> <li> <p> </p> <p> Soldering Iron - 60W (Adjustable Temperature)    TOL-14456 </p> </li> </ul> <ul> <li> <p> </p> <p> Solder Lead Free - 15-gram Tube    TOL-09163 </p> </li> </ul> <ul> <li> <p> </p> <p> Hook-Up Wire - Assortment (Stranded, 22 AWG)    PRT-11375 </p> </li> </ul> <ul> <li> <p> </p> <p> Wire Strippers - 30AWG (Hakko)    TOL-12630 </p> </li> </ul> <ul> <li> <p> </p> <p> Flush Cutters - Hakko    TOL-11952 </p> </li> </ul> <ul> <li> <p> </p> <p> Digital Multimeter - Basic    TOL-12966 </p> </li> </ul> <ul> <li> <p> </p> <p> Fast Charging USB A to C Cable with LCD - 4ft (6A)    CAB-19718 </p> </li> </ul>"},{"location":"introduction/#prototyping-accessories","title":"Prototyping Accessories","text":"<p>Depending on your setup, you may want to use IC hooks for a temporary connection. However, you will want to solder header pins to connect devices to the plated through holes for a secure connection.</p> <ul> <li> <p> </p> <p> Breadboard - Self-Adhesive (White)    PRT-12002 </p> </li> </ul> <ul> <li> <p> </p> <p> IC Hook with Pigtail    CAB-09741 </p> </li> </ul> <ul> <li> <p> </p> <p> Break Away Headers - Straight    PRT-00116 </p> </li> </ul> <ul> <li> <p> </p> <p> Feather Stackable Header Kit    PRT-15187 </p> </li> </ul> <ul> <li> <p> </p> <p> Jumper - 2 Pin    PRT-09044 </p> </li> </ul> <ul> <li> <p> </p> <p> Jumper Wires Premium 6\" M/M Pack of 10    PRT-08431 </p> </li> </ul>"},{"location":"introduction/#qwiic-cables","title":"Qwiic Cables","text":"<p>For those that want to take advantage of the Qwiic enabled devices, you'll want to grab a Qwiic cable.</p> <ul> <li> <p> </p> <p> SparkFun Qwiic Cable Kit    KIT-15081 </p> </li> </ul> <ul> <li> <p> </p> <p> Qwiic Cable - 100mm    PRT-14427 </p> </li> </ul> <ul> <li> <p> </p> <p> Qwiic Cable - 500mm    PRT-14429 </p> </li> </ul> <ul> <li> <p> </p> <p> Qwiic Cable - Breadboard Jumper (4-pin)    PRT-14425 </p> </li> </ul>"},{"location":"introduction/#lipo-battery","title":"LiPo Battery","text":"<p>A single-cell Lithium-ion battery can be connected to the SparkFun Thing Plus NORA-W306 for portability.</p> <ul> <li> <p> </p> <p> Lithium Ion Battery - 1250mAh (IEC62133 Certified)    PRT-18286 </p> </li> </ul> <ul> <li> <p> </p> <p> Lithium Ion Battery - 850mAh    PRT-13854 </p> </li> </ul> <ul> <li> <p> </p> <p> Lithium Ion Battery - 6Ah    PRT-13856 </p> </li> </ul>"},{"location":"introduction/#suggested-reading","title":"Suggested Reading","text":"<p>If you aren't familiar with the Qwiic Connection System, we recommend reading here for an overview.</p> Qwiic Connection System <p>If you aren\u2019t familiar with the following concepts, we also recommend checking out a few of these tutorials before continuing.</p> <ul> <li> <p> </p> <p> How to Solder: Through-Hole Soldering </p> </li> </ul> <ul> <li> <p> </p> <p> Installing Arduino IDE </p> </li> </ul> <ul> <li> <p> </p> <p> Arduino Shields V2 </p> </li> </ul> <ul> <li> <p> </p> <p> I2C </p> </li> </ul> <ul> <li> <p> </p> <p> Installing Board Definitions in the Arduino IDE </p> </li> </ul> <ul> <li> <p> </p> <p> Serial Communication </p> </li> </ul> <ul> <li> <p> </p> <p> Serial Peripheral Interface (SPI) </p> </li> </ul> <ul> <li> <p> </p> <p> Pulse Width Modulation </p> </li> </ul> <ul> <li> <p> </p> <p> Logic Levels </p> </li> </ul> <ul> <li> <p> </p> <p> Analog vs. Digital </p> </li> </ul> <ul> <li> <p> </p> <p> WS2812 Breakout Hookup Guide </p> </li> </ul> <ul> <li> <p> </p> <p> Single Cell LiPo Battery Care </p> </li> </ul> <ul> <li> <p> </p> <p> LiPo Fuel Gauge (MAX1704X) Hookup Guide </p> </li> </ul>"},{"location":"more_examples/","title":"More Examples!!!","text":"<p>Of course, this only skims the surface of what the SparkFun Thing Plus - NORA-W306 can do. There are a handful of examples from the board support package that were not highlighted in this tutorial and are being ported by our friends at Realtek with the NORA-W306 module. From the menu, try opening the other examples listed for hte board: File &gt; Examples &gt; Examples for AW_CU488 Thing Plus (RTL8721DM)</p> More Arduino Examples! <p>Note</p> <p>Some of the examples listed in the menu may still be under development. Make sure to be patient as they include more support for the NORA-W306 module.</p> <p>Or try adding another Qwiic-enabled device or a breakout board to your next project!</p> Qwiic Connect System"},{"location":"resources/","title":"Resources","text":"<p>Now that you've successfully got your SparkFun Thing Plus - NORA-W306 up and running, it's time to incorporate it into your own project! For more information, check out the resources below:</p> <ul> <li>Schematic (PDF)</li> <li>Eagle Files (ZIP)</li> <li>Board Dimensions (PNG)</li> <li>Component Datasheets<ul> <li>u-blox NORA-W306<ul> <li>Product Summary (PDF)</li> <li>Datasheet (PDF)</li> <li>Integration Manual (PDF)</li> </ul> </li> <li>XC6222 3.3V/700mA Voltage Regulator (PDF)</li> <li>MCP73831 LiPo Charger (PDF)</li> <li>MAX17048 LiPo Fuel Gauge (PDF)</li> <li>WS2812C-2020 RGB Addressable LED (PDF)</li> </ul> </li> <li>Graphical Datasheet</li> <li>Fritzing Part</li> <li>Qwiic Info Page</li> <li>Compare Thing Plus Boards</li> <li>CP210X Drivers</li> <li>Realtek: Arduino Board Support Files</li> <li>Arduino Libraries<ul> <li>MAX17048</li> <li>SdFat</li> <li>Qwiic OLED</li> </ul> </li> <li>GitHub Hardware Repo</li> <li>SFE Product Showcase</li> </ul>"},{"location":"setting_up_arduino/","title":"Setting Up Arduino","text":"<p>Arduino</p> <p>This example assumes you are using the latest version of the Arduino IDE on your desktop. If this is your first time using Arduino IDE, library, or board add-on, please review the following tutorials.</p> <ul> <li>Installing the Arduino IDE</li> <li>Installing an Arduino Library</li> <li>Installing Board Definitions in the Arduino IDE</li> </ul>"},{"location":"setting_up_arduino/#install-the-realtek-board-add-on","title":"Install the Realtek Board Add-on","text":"<p>First, open your Arduino preferences (File &gt; Preferences). Then find the Additional Boards Manager URLs text box, and paste the below link in. If you have other links for other 3rd party boards, you will need to add a comma (<code>,</code>) between each link in the field. You can also open an additional window by clicking the window button next to the Additional Boards Manager URLs: field and add the link to a separate line.</p> <pre><code>https://github.com/ambiot/ambd_arduino/raw/dev/Arduino_package/package_realtek_amebad_early_index.json\n</code></pre> Realtek Arduino Board Support Files for the NORA-W306 <p>Then hit \"OK\", and travel back to the Board Manager menu. Type \"realtek\" in the search bar and hit enter. Click on the \"Install\" button for the Realtek Ameba Boards (32-bit ARM Cortex-M33 @200MHz) by Realtek. Downloading and installing the tools may take a couple minutes. Feel free to walk around, grab some water, or do a little dance while the tools install.</p> Search for realtek in Arduino Boards Manager <p>Once installed, the version number and Arduino-blue \"INSTALLED\" text should appear next to the boards list entry.</p> Installed Realtek Arduino Core"},{"location":"setting_up_arduino/#selecting-the-sparkfun-thing-plus-nora-306","title":"Selecting the SparkFun Thing Plus NORA-306","text":"<p>To upload code to the board, you will need to select the correct board. From the menu, select the following: Tools &gt; Board &gt; Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz) &gt; SparkFun Thing Plus NORA-306 (RTL8720DF) .</p> Screenshot Board Selection <p>There are a few options for the board. One of them is the option to automatically upload code to the board without the need to press the BOOT and RESET buttons as Arduino uploads your code. By default, the Auto Upload Mode is disabled. From the menu, select the following: Tools &gt; Auto Upload Mode: &gt; Enable .</p> Screenshot of Auto Upload Mode"},{"location":"setting_up_arduino/#com-port-selection","title":"COM Port Selection","text":"<p>You will also need to select the COM port that the board enumerated to. From the menu, select your respective COM port on your computer (in this case, it was COM13 on a Windows computer): Tools &gt; Port &gt; COM___ .</p> Screenshot COM Port Selection"},{"location":"single_page/","title":"Introduction","text":"<p>The SparkFun Thing Plus - NORA-W306 is a Feather form-factor development board equipped with the u-blox NORA-W306 module. The module contains a Realtek RTL8720DF, which has an integrated single-chip low-power dual-band (2.4GHz and 5GHz) Wireless LAN (WLAN) and Bluetooth\u00ae Low Energy (BLE 5.3) communication microcontroller. It also consists of a dual processor core: Arm Cortex-M33 and Cortex-M23. To complement the module's low-power options, we've optimized components and added the ability to depower all subsystems to conserve as much power as possible for remote battery-powered applications.</p> <ul> <li> <p> </p> <p> SparkFun Thing Plus NORA-W306    WRL-21637    Purchase from SparkFun  </p> </li> </ul> <p>In this tutorial, we'll go over the hardware and how to hookup the development board to an Arduino. We will also go over a few Arduino examples to get started!</p>"},{"location":"single_page/#required-materials","title":"Required Materials","text":"<p>To follow along with this tutorial, you will need the following materials. You may not need everything though depending on what you have. Add it to your cart, read through the guide, and adjust the cart as necessary.</p> <ul> <li> <p> </p> <p> Reversible USB A to C Cable - 0.8m    CAB-15425 </p> </li> </ul> <ul> <li> <p> </p> <p> SparkFun Thing Plus NORA-W306    WRL-21637 </p> </li> </ul> <ul> <li> <p> </p> <p> microSD Card - 1GB (Class 4)    COM-15107 </p> </li> </ul> <ul> <li> <p> </p> <p> SparkFun Micro OLED Breakout (Qwiic)    SEN-22495 </p> </li> </ul> <ul> <li> <p> </p> <p> Flexible Qwiic Cable - 50mm    PRT-17260 </p> </li> </ul> <p>Note</p> <p>Make sure that you have a microSD card reader or adapter as well to read the contents saved on the memory card.</p> <p> MicroSD Card Adapters"},{"location":"single_page/#tools-optional","title":"Tools (Optional)","text":"<p>You will need a soldering iron, solder, and general soldering accessories for a secure connection when using the plated through holes. For users that are measuring the current draw, you may want to consider grabbing a digital multimeter or a USB C cable that is able to display the current draw.</p> <ul> <li> <p> </p> <p> Soldering Iron - 60W (Adjustable Temperature)    TOL-14456 </p> </li> </ul> <ul> <li> <p> </p> <p> Solder Lead Free - 15-gram Tube    TOL-09163 </p> </li> </ul> <ul> <li> <p> </p> <p> Hook-Up Wire - Assortment (Stranded, 22 AWG)    PRT-11375 </p> </li> </ul> <ul> <li> <p> </p> <p> Wire Strippers - 30AWG (Hakko)    TOL-12630 </p> </li> </ul> <ul> <li> <p> </p> <p> Flush Cutters - Hakko    TOL-11952 </p> </li> </ul> <ul> <li> <p> </p> <p> Digital Multimeter - Basic    TOL-12966 </p> </li> </ul> <ul> <li> <p> </p> <p> Fast Charging USB A to C Cable with LCD - 4ft (6A)    CAB-19718 </p> </li> </ul>"},{"location":"single_page/#prototyping-accessories","title":"Prototyping Accessories","text":"<p>Depending on your setup, you may want to use IC hooks for a temporary connection. However, you will want to solder header pins to connect devices to the plated through holes for a secure connection.</p> <ul> <li> <p> </p> <p> Breadboard - Self-Adhesive (White)    PRT-12002 </p> </li> </ul> <ul> <li> <p> </p> <p> IC Hook with Pigtail    CAB-09741 </p> </li> </ul> <ul> <li> <p> </p> <p> Break Away Headers - Straight    PRT-00116 </p> </li> </ul> <ul> <li> <p> </p> <p> Feather Stackable Header Kit    PRT-15187 </p> </li> </ul> <ul> <li> <p> </p> <p> Jumper - 2 Pin    PRT-09044 </p> </li> </ul> <ul> <li> <p> </p> <p> Jumper Wires Premium 6\" M/M Pack of 10    PRT-08431 </p> </li> </ul>"},{"location":"single_page/#qwiic-cables","title":"Qwiic Cables","text":"<p>For those that want to take advantage of the Qwiic enabled devices, you'll want to grab a Qwiic cable.</p> <ul> <li> <p> </p> <p> SparkFun Qwiic Cable Kit    KIT-15081 </p> </li> </ul> <ul> <li> <p> </p> <p> Qwiic Cable - 100mm    PRT-14427 </p> </li> </ul> <ul> <li> <p> </p> <p> Qwiic Cable - 500mm    PRT-14429 </p> </li> </ul> <ul> <li> <p> </p> <p> Qwiic Cable - Breadboard Jumper (4-pin)    PRT-14425 </p> </li> </ul>"},{"location":"single_page/#lipo-battery","title":"LiPo Battery","text":"<p>A single-cell Lithium-ion battery can be connected to the SparkFun Thing Plus NORA-W306 for portability.</p> <ul> <li> <p> </p> <p> Lithium Ion Battery - 1250mAh (IEC62133 Certified)    PRT-18286 </p> </li> </ul> <ul> <li> <p> </p> <p> Lithium Ion Battery - 850mAh    PRT-13854 </p> </li> </ul> <ul> <li> <p> </p> <p> Lithium Ion Battery - 6Ah    PRT-13856 </p> </li> </ul>"},{"location":"single_page/#suggested-reading","title":"Suggested Reading","text":"<p>If you aren't familiar with the Qwiic Connection System, we recommend reading here for an overview.</p> Qwiic Connection System <p>If you aren\u2019t familiar with the following concepts, we also recommend checking out a few of these tutorials before continuing.</p> <ul> <li> <p> </p> <p> How to Solder: Through-Hole Soldering </p> </li> </ul> <ul> <li> <p> </p> <p> Installing Arduino IDE </p> </li> </ul> <ul> <li> <p> </p> <p> Arduino Shields V2 </p> </li> </ul> <ul> <li> <p> </p> <p> I2C </p> </li> </ul> <ul> <li> <p> </p> <p> Installing Board Definitions in the Arduino IDE </p> </li> </ul> <ul> <li> <p> </p> <p> Serial Communication </p> </li> </ul> <ul> <li> <p> </p> <p> Serial Peripheral Interface (SPI) </p> </li> </ul> <ul> <li> <p> </p> <p> Pulse Width Modulation </p> </li> </ul> <ul> <li> <p> </p> <p> Logic Levels </p> </li> </ul> <ul> <li> <p> </p> <p> Analog vs. Digital </p> </li> </ul> <ul> <li> <p> </p> <p> WS2812 Breakout Hookup Guide </p> </li> </ul> <ul> <li> <p> </p> <p> Single Cell LiPo Battery Care </p> </li> </ul> <ul> <li> <p> </p> <p> LiPo Fuel Gauge (MAX1704X) Hookup Guide </p> </li> </ul>"},{"location":"single_page/#hardware-overview","title":"Hardware Overview","text":"<p>In this section, we will highlight the hardware and pins that are broken out on the SparkFun Thing Plus NORA-W306. For more information, check out our Resources and Going Further for the u-blox NORA-W306 module or Realtek RTL8720DF that is contained within the module.</p> Top View Bottom View"},{"location":"single_page/#power","title":"Power","text":"<p>There are a variety of power and power-related nets broken out to connectors and through hole pads. Power is regulated down to 3.3V for the NORA-W306 so the logic level is 3.3V. There are Schottky diode and transistors to safely select voltage from the USB or LiPo battery. This avoids any conflicting voltages between the two sources.</p> <ul> <li>VU or VUSB \u2014 The V_BUS net is connected to the USB Type C connector and the VU/VUSB PTH. You can use 5V from a USB port by connecting to the USB Type C connector or connecting power to the VBUS PTH. Make sure that power you provide to this pin does not exceed 6 volts. Power is regulated down with the XC6222 3.3V/700mA voltage regulator. The USB Type C connector is also used to upload code to your processor, send serial data to a terminal window, or charging the LiPo battery. Of course for portable power, you could connect a USB battery as an alternative to using a LiPo battery.</li> <li>VB \u2014  The V_BATT net is connected to the 2-pin JST style connector, VB PTH, and the NORA-W306's MEAS pin. For portable applications, you can connect a nominal 3.7V single cell, LiPo battery to the 2-pin JST style connector. This pin is also connected to the MCP73831 charge IC to safely charge the LiPo battery to its maximum voltage of about 4.2V. We recommend connecting only LiPo batteries to the VBAT net to power the board. Of course, you can power a separate device through the VBAT PTH pin. Power is regulated down with the XC6222 3.3V/700mA voltage regulator.</li> <li>3V or 3V3 \u2014 The 3.3V net is labeled as 3V or 3V3. You can apply power to the board if you have a regulated voltage of 3.3V. Otherwise, you could power a separate device through the 3V3 PTH pin. This is also connected to the Qwiic connector's 3.3V pin to power Qwiic enabled devices.</li> <li>EN \u2014 The 3.3V voltage regulator's EN pin is labeled as EN. Pulling this pin low will disable the 3.3V voltage regulator.</li> <li>G or GND \u2014 Of course, is the common, ground voltage (0V reference) for the system.</li> </ul> Power, Ground, and Connectors Highlighted(Top &amp; Bottom View) <p>Note</p> <p>You will notice the pads of the SWD pins are also highlighted! 3.3V and ground are also connected to these pads. Users can easily access these pins using a SWD header and cable. Of course, you could also solder wire to those pads if you needed another way to connect to the traces.</p> <p>Tip</p> <p>To complement the module's low-power options, we've optimized components and added the ability to depower all subsystems to conserve as much power as possible for remote battery-powered applications. Without a battery attached or charging, and cutting the power to WS2812 (i.e. jumper JP3); the current draw was as low as 14\u00b5A in low power mode! Amazing! Under normal conditions, we measured the current draw as low as 30mA.</p> <p>Let's compare the Thing Plus ESP32 (USB-C) against the Thing Plus NORA-W306. The power LED jumper was cut on the Thing Plus ESP32. A microSD card was inserted in the microSD card socket (which does not have a way to turn off power through a GPIO) and the board was powered via a single cell LiPo battery. The current draw was 884\u00b5A in deep sleep mode while it was 40mA when awake.</p> <p>For the Thing Plus NORA-W306, we cut the power LED and WS28112 LED jumpers. The SDPC (microSD Power Control) jumper was modified so power to the microSD card can be controlled through GPIO 17. A microSD card was inserted in the microSD card socket. With the MEAS jumper cut, a multimeter (set to measure current) was connected to monitor the current draw. Power was also provided via a single cell LiPo battery. The current draw was 115\u00b5A in deep sleep mode while it was 21mA when awake.</p> <p>For more information, check out the demo video below with current draw for the board in low power mode!</p> <p> </p>"},{"location":"single_page/#lipo-charge-circuit","title":"LiPo Charge Circuit","text":"<p>The board includes the MCP73831 LiPo charger IC (the little black IC with 5 pins highlighted) to safely charge a single cell, LiPo battery. In this case, the charge rate is set to a default rate of 500mA. Cutting the trace on the back while adding a solder jumper between the middle pad and the pad labeled as 100mA will set the charge rate to 100mA. The on-board LED (not highlighted) labeled as CHG can be used to get an indication of the charge status of your battery.</p> 2-pin JST Style Connector, LiPo Charger IC, and VBATT PTH Highlighted(Top View) <p>Note</p> <p>For more information on proper handling of LiPo batteries, check out the tutorial on Single Cell LiPo Battery Care.</p> <ul> <li> <p> </p> <p> Single Cell LiPo Battery Care </p> </li> </ul> <p> </p>"},{"location":"single_page/#gpio","title":"GPIO","text":"<p>The SparkFun Thing Plus - NORA-W306 breaks out the GPIO pins to plated through hole pads on the edge of the board using the Thing Plus/Feather Form Factor. Each of the pins on the edge of the board are tired to various components on the board. Check below for more information on each connection!</p> GPIO Pins Highlighted(Top &amp; Bottom View) <p>Note that the pin label might have additional functionality that may not be apparent from the silkscreen. Below is a graphical datasheet of the SparkFun Thing Plus - NORA-W306 that highlights the additional functionality.</p> Graphical Datasheet <p>Note</p> <p>While the u-blox integration manual may have pins highlighted to show additional functionality, there are some that are not supported in the Realtek's Arduino core. Some of these features that are not supported in the Arduino core include SDIO, I2S, IR, and RTC.</p>"},{"location":"single_page/#swd","title":"SWD","text":"<p>For advanced users, the SWD pins are broken out on the 2x5 header on the back of the board. Note that this is not populated so you will need to solder a compatible header, 2x5 SWD cable, and compatible JTAG programmer to connect. These pins are also connected to the edge of the board.</p> SWD Pins Highlighted <p>Note</p> <p>Pin <code>10</code> is tied to the SWD Data pad and <code>A0</code> is tied to SWD CLK pad on the back of the board.</p>"},{"location":"single_page/#reset-and-boot-buttons","title":"Reset and Boot Buttons","text":"<p>Each board includes a RESET and BOOT button. There is an additional reset PTH next to the reset button. Hit the reset button to restart the NORA-W306. To manually place the NORA-W306 into boot mode, hold down the BOOT button while pressing the RESET button momentarily and then release the BOOT button.</p> Reset and Boot Pins and Buttons Highlighted(Top &amp; Bottom View) <p>Note</p> <p>The BOOT button is also connected to pin 0 (TX). The datasheet refers to this pin as the CHIP_EN.</p> <p>Note</p> <p>You will notice a pad of the SWD is also highlighted. The reset pin is connected to this pad. Users can easily access these pins using a SWD header and cable. Of course, you could also solder wire to those pads if you needed another way to connect to the traces.</p>"},{"location":"single_page/#user-button","title":"User Button","text":"<p>The board also includes a user button that is connected pin <code>2</code>.</p> Reset &amp; Boot Pins and Buttons Highlighted(Top &amp; Bottom View) <p>Note</p> <p>When defining the pin for the user button, make sure to use an internal pull-up resistor so that the button is not floating.</p> <p>Tip</p> <p>Need a bigger button? Users can connect pin 2 on the edge of the board to an external button!</p>"},{"location":"single_page/#interrupts","title":"Interrupts","text":"<p>Speaking of buttons, all GPIOs can also be set as interrupts!</p> Interrupt Pins Highlighted(Top &amp; Bottom View)"},{"location":"single_page/#uart","title":"UART","text":"<p>There are two UARTs. The primary hardware UART (UART0) is connected to the USB-to-serial converter. The secondary hardware UART (UART1) is broken out to the edge of the board. We recommend connecting a UART device to the secondary hardware UART to avoid any bus contention with the CP2102N.</p> UARTs Highlighted(Top &amp; Bottom View)"},{"location":"single_page/#cp2102n-usb-to-serial-converter","title":"CP2102N USB-to-Serial Converter","text":"<p>The board includes the CP2102N USB-to-Serial converter. This is used for serial programming or communicating with a serial terminal. The CP2102N is connected to the NORA-W306's primary hardware UART (UART0): TX pin is connected to pin <code>0</code> (RX0) while and RX pin is connected to pin <code>1</code> (TX0).</p> USB-to-Serial Converter, USB, and UART0 Highlighted(Top &amp; Bottom View)"},{"location":"single_page/#qwiic-and-i2c","title":"Qwiic and I<sup>2</sup>C","text":"<p>The board includes one horizontal Qwiic connector on the board. These pins are connected to the primary I<sup>2</sup>C bus and power (e.g. 3.3V and GND) allowing you to easily add a Qwiic-enabled device to your application. The I<sup>2</sup>C data and clock lines are also tied to 2.2k\u03a9 pull-up resistors. The I<sup>2</sup>C SCL pin is connected to <code>12</code>. The I<sup>2</sup>C SDA is connected to <code>11</code>.</p> I<sup>2</sup>C and Qwiic Connector Highlighted(Top &amp; Bottom View)"},{"location":"single_page/#lipo-fuel-gauge-max17048","title":"LiPo Fuel Gauge - MAX17048","text":"<p>Built into the board is also the single cell LiPo Fuel Gauge, specifically the MAX17408. The 7-bit, unshifted address of the MAX17048 is 0x36. The address becomes 0x6C for write and 0x6D for read.  </p> LiPo Fuel Gauge - MAX17048 Highlighted(Top View)"},{"location":"single_page/#spi","title":"SPI","text":"<p>There are two SPI ports available. The primary SPI pins (SPI0) is broken out as:  <code>5</code> (SPI0_SCK), <code>6</code> (SPI0_PICO), <code>7</code> (SPI0_POCI), and <code>4</code> (SPI0_CS). These are also connected to the microSD card that is populated on the back. The secondary SPI pins (SPI1) is broken out as: <code>16</code> (SPI1_SCK), <code>14</code> (SPI1_PICO), <code>13</code> (SPI1_POCI), and <code>15</code> (SPI1_CS)</p> SPI Pins Highlighted(Top &amp; Bottom View) <p>Note</p> <p>Pin <code>14</code> is also connected to the addressable LED. The Realtek Arduino Core needed to use this specific SPI pin to control WS2812. Users can disable the addressable LED by cutting JP1 on the back of the board.</p>"},{"location":"single_page/#microsd-card-socket","title":"MicroSD Card Socket","text":"<p>Built into the board is a microSD card socket to log data. As explained in the SPI section, the data lines are connected to the primary SPI pins (SPI0). One special feature that is different from other Thing Plus boards is the transistor to toggle power to the microSD card socket. By default, it is always on. For users that want to conserve power, you can cut the jumper for the SDPC. You will then need to add a solder blob between the center pad and the pad that is labeled 17.</p> Micro SD Card, Transistor, and Power Enable Pin Highlighted(Top &amp; Bottom View)"},{"location":"single_page/#pulse-width-modulation-pwm","title":"Pulse Width Modulation (PWM)","text":"<p>There are 12x PWM pins available: <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>11</code>, <code>12</code>, <code>13</code>, <code>14</code>, <code>17</code>, and <code>18</code>. Note that these are tied to other peripherals as well.</p> PWM Pins Highlighted(Top &amp; Bottom View)"},{"location":"single_page/#analog","title":"Analog","text":"<p>There are 3x 12-bit analog pins available: <code>A0</code>, <code>A1</code>, and <code>A2</code>.</p> ADC Pins Highlighted(Top &amp; Bottom View)"},{"location":"single_page/#leds","title":"LEDs","text":"<p>There are 4x LEDs populated on the board.</p> <ul> <li>PWR \u2014 The PWR LED lights up to indicate when there is a 3.3V available after power is regulated down from the USB connector or LiPo battery. This can be disabled by cutting the jumper labeled as PWR.</li> <li>CHG \u2014 The on-board yellow CHG LED can be used to get an indication of the charge status of your battery. Below is a table of other status indicators depending on the state of the charge IC. This can be disabled by cutting the jumper labeled as CHG.</li> <li>RGB IO14 \u2014 The RGB IO14 LED is an WS2812-2020 LED. Users can control this addressable RGB LED using pin <code>14</code>. This LED can be disconnected from the pin by cutting the jumper labeled as JP1. For users that are not using this LED and want to conserve power, the 3.3V net can also be disconnected as well by cutting the jumper labeled as JP3. For users that are interested in daisy chaining additional WS2812 LEDs, users can connect to the PTH labled as LD or LED D0.</li> <li>IO18 \u2014 The LED labeled as IO18 can be configured by the user and is connected to pin <code>18</code>. This can be disconnect from the pin by cutting the jumper labeled JP2.</li> </ul> Charge State LED status No Battery Floating (should be OFF, but may flicker) Shutdown Floating (should be OFF, but may flicker) Charging ON Charge Complete OFF LEDs and Connected PTHs Highlighted(Top &amp; Bottom View)"},{"location":"single_page/#jumpers","title":"Jumpers","text":"<p>Note</p> <p>If this is your first time working with jumpers, check out the How to Work with Jumper Pads and PCB Traces tutorial for more information.</p> <p>There are a few jumper pads available on the bottom of the board.</p> <ul> <li>SHLD \u2014 This jumper connects the USB Type C connector's shield pin to GND. Cut this to isolate the USB Type C connector's shield pin. This is for advanced users that want to ground their board to their enclosure instead of the ground plane.</li> <li>MEAS \u2014 To enable measurements and determine how long your battery might last, we've added a NC (normally closed) jumper between the two MEAS PTH pins. By cutting this jumper, the voltage connecting to the 3.3V voltage regulator input is interrupted. Soldering in a male jumper or wires into the accompanying holes will give you the ability to insert a current meter and precisely monitor how much current your application is consuming.</li> <li>PWR \u2014 By default, this jumper is closed. Cut this trace to disable the power LED that is connected to 3.3V.</li> <li>CHG \u2014 By default, this jumper is closed. Cut this trace to disable the charge LED that is connected to the LiPo charge IC.</li> <li>LED_D0 \u2014 By default, this jumper is closed. Cut this trace to disable the WS2812 addressable RGB LED's output pin labeled as <code>D0</code>.</li> <li>JP1 \u2014 By default, this jumper is closed. Cut this trace to disable the WS2812 addressable RGB LED's input pin that is connected to pin <code>14</code>.</li> <li>JP2 \u2014 By default, this jumper is closed. Cut this trace to disable the user LED that is connected to pin <code>18</code>.</li> <li>JP3 \u2014 By default, this jumper is closed. Cut this trace to disable power connected to the WS2812 addressable LED's 3.3V pin.</li> <li>CUR \u2014 This three way jumper sets the charge IC's charge rate. By default, it's connected to the pad labeled 500 so the charge rate is set to 500mA. Cutting a trace and adding a solder jumper between the center pad and the pad labeled as 100 will set the charge rate to 100mA.</li> <li>I2C \u2014 By default, this three-pad jumper is closed and located on the bottom of the board. The three way jumper labeled I2C connect the two 2.2k\u03a9 pull-up resistors to the I<sup>2</sup>C data and clock lines. If multiple devices are connected to the bus with the pull-up resistors enabled, the parallel equivalent resistance will create too strong of a pull-up for the bus to operate correctly. As a general rule of thumb, disable all but one pair of pull-up resistors if multiple devices are connected to the bus.</li> <li>SDPC \u2014 By default, this jumper is closed and for the microSD card's power control circuit. Cut this trace on the GND/ON side to disable power to the microSD card's socket. For users that want to control the transistor via a GPIO, add a solder blob between the center pad and the pad that is labeled 17. Make sure to also define the pin in code to toggle power to the microSD card.</li> </ul> Jumpers Highlighted(Top &amp; Bottom View)"},{"location":"single_page/#board-dimensions","title":"Board Dimensions","text":"<p>The board is 0.9\" x 2.3\" (22.86mm x 58.42mm) and uses the standard Thing+ footprint. There are 4x mounting holes by each corner of the board. You can use 4-40 standoffs to mount the board to a panel or enclosure.</p> Board Dimensions"},{"location":"single_page/#hardware-hookup","title":"Hardware Hookup","text":"<p>At a minimum, you will need to plug in the USB C cable to the SparkFun Thing Plus NORA-W306 to power and program the board.</p> USB Cable inserted into Thing Plus NORA-W306"},{"location":"single_page/#single-cell-lipo-battery","title":"Single Cell LiPo Battery","text":"<p>Battery Polarity</p> <p>Please make sure that you use one of our recommended Lithium Ion batteries. Some batteries use the same JST connector as ours but have the opposite polarity. Connecting one of these to your SparkFun Thing Plus NORA-W306 will destroy it. If you are going to use your own battery, it is up to you to ensure it has the correct polarity.</p> <p>For remote applications, you can connect a standard single cell LiPo battery. The SparkFun Thing Plus NORA-W306 has a built-in charger too which will charge your battery at 500mA when a USB-C is connected. Please make sure your battery capacity is at least 500mAh (0.5Ah); bad things will happen if you try to charge smaller batteries using the board's default charge rate of 500mA. Of course, you can adjust the charge rate with the 3-way jumper on the back of the board. The yellow CHG charging LED will light up while the battery is charging and will turn off once charging is complete.</p> Battery Connected <p>The MCP73831 charge IC on the board is used on a few SparkFun products. For more information about the CHG status LED, we recommend taking look at the Hardware Overview. We also recommend taking a look at this tutorial for Single Cell LiPo Battery Care.</p> <ul> <li> <p> </p> <p> Single Cell LiPo Battery Care </p> </li> </ul>"},{"location":"single_page/#inserting-a-microsd-card","title":"Inserting a MicroSD Card","text":"<p>For those that need to store data, you can add a microSD card to your application. You will just need to insert a microSD card with the metal contacts facing the board and into the socket on the back. Compared to other microSD cards sockets in sparkFun's storefront, this will not have a click to lock the memory card in place. Just make sure to fully insert the memory card.</p> MicroSD Card in Socket <p>You should only insert or remove the SD card while the power is turned off or disconnected. Removing the card while the SparkFun Thing Plus NORA-W306 is powered will almost certainly corrupt your data.</p>"},{"location":"single_page/#connecting-via-qwiic","title":"Connecting via Qwiic","text":"<p>For users that want to connect a Qwiic-enabled device, you will simply need to insert a cable between the Qwiic connectors. Then insert a USB cable between the microcontroller and your computer to power and program.</p> Qwiic-enabled Device Connected to Thing Plus NORA-W306"},{"location":"single_page/#connecting-via-pth","title":"Connecting via PTH","text":"<p>For temporary connections to the PTHs, you could use IC hooks to test out the pins. However, you'll need to solder headers or wires of your choice to the board for a secure connection. You can choose between a combination of header pins and jumper wires, or stripping wire and soldering the wire directly to the board.</p> <ul> <li> <p> </p> <p> How to Solder: Through Hole Soldering </p> </li> </ul> <ul> <li> <p> </p> <p> Working with Wire </p> </li> </ul>"},{"location":"single_page/#installing-the-cp2102-usb-driver","title":"Installing the CP2102 USB Driver","text":"<p>Warning</p> <p>Make sure to manually install the driver for the CP2102N with the following instructions. The driver that Windows auto-installs will not work with the auto-reset circuit on the board and can cause serial uploads to fail.</p> <p>You will also need to install the SiLabs CP210X Driver, which can be found here: USB to UART Bridge VCP Driver.</p> Windows VCP Driver (ZIP) Mac OSX VCP Driver (ZIP) <p>Note</p> <p>If applicable, make sure you are using the proper driver files for your CPU architecture. This is usually indicated by a folder or file name with \"x86\" for 32-bit processors or \"x64\" for 64-bit processors.</p>"},{"location":"single_page/#setting-up-arduino","title":"Setting Up Arduino","text":"<p>Arduino</p> <p>This example assumes you are using the latest version of the Arduino IDE on your desktop. If this is your first time using Arduino IDE, library, or board add-on, please review the following tutorials.</p> <ul> <li>Installing the Arduino IDE</li> <li>Installing an Arduino Library</li> <li>Installing Board Definitions in the Arduino IDE</li> </ul>"},{"location":"single_page/#install-the-realtek-board-add-on","title":"Install the Realtek Board Add-on","text":"<p>First, open your Arduino preferences (File &gt; Preferences). Then find the Additional Boards Manager URLs text box, and paste the below link in. If you have other links for other 3rd party boards, you will need to add a comma (<code>,</code>) between each link in the field. You can also open an additional window by clicking the window button next to the Additional Boards Manager URLs: field and add the link to a separate line.</p> <pre><code>https://github.com/ambiot/ambd_arduino/raw/dev/Arduino_package/package_realtek_amebad_early_index.json\n</code></pre> Realtek Arduino Board Support Files for the NORA-W306 <p>Then hit \"OK\", and travel back to the Board Manager menu. Type \"realtek\" in the search bar and hit enter. Click on the \"Install\" button for the Realtek Ameba Boards (32-bit ARM Cortex-M33 @200MHz) by Realtek. Downloading and installing the tools may take a couple minutes. Feel free to walk around, grab some water, or do a little dance while the tools install.</p> Search for realtek in Arduino Boards Manager <p>Once installed, the version number and Arduino-blue \"INSTALLED\" text should appear next to the boards list entry.</p> Installed Realtek Arduino Core"},{"location":"single_page/#selecting-the-sparkfun-thing-plus-nora-306","title":"Selecting the SparkFun Thing Plus NORA-306","text":"<p>To upload code to the board, you will need to select the correct board. From the menu, select the following: Tools &gt; Board &gt; Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz) &gt; SparkFun Thing Plus NORA-306 (RTL8720DF) .</p> Screenshot Board Selection <p>There are a few options for the board. One of them is the option to automatically upload code to the board without the need to press the BOOT and RESET buttons as Arduino uploads your code. By default, the Auto Upload Mode is disabled. From the menu, select the following: Tools &gt; Auto Upload Mode: &gt; Enable .</p> Screenshot of Auto Upload Mode"},{"location":"single_page/#com-port-selection","title":"COM Port Selection","text":"<p>You will also need to select the COM port that the board enumerated to. From the menu, select your respective COM port on your computer (in this case, it was COM13 on a Windows computer): Tools &gt; Port &gt; COM___ .</p> Screenshot COM Port Selection"},{"location":"single_page/#installing-the-arduino-library","title":"Installing the Arduino Library","text":"<p>To take advantage of a few of the built-in components on the board, you will need to install a Arduino Library. Of course, you may need additional Arduino Libraries depending on what you connect to the development board. At a minimum, you will need the following listed below to take advantage of the built-in LiPo Fuel Gauge (MAX17048).</p>"},{"location":"single_page/#sparkfun-max1704x-fuel-gauge-arduino-library","title":"SparkFun MAX1704x Fuel Gauge Arduino Library","text":"<p>SparkFun has written a library to work with the LiPo Fuel Gauge - MAX17048 that is built into the SparkFun Thing Plus NORA-W306. You can obtain this library through the Arduino Library Manager by searching for \"SparkFun MAX1704x Fuel Gauge\". Find the one written by SparkFun Electronics and install the latest version. Users who prefer to manually install the library can get it from the  GitHub Repository or download the .ZIP by clicking the button below:</p> SparkFun MAX1704x Fuel Gauge Arduino Library (ZIP)"},{"location":"single_page/#sdfat-arduino-library","title":"SdFat Arduino Library","text":"<p>Bill Greiman has written a library for memory cards formatted to FAT16/FAT32 exFAT. We used this Arduino Library instead of the ones that were listed in the libraries included with the AmebaD. You can obtain this library through the Arduino Library Manager by searching for \"sdfat\". Find the one written by Bill Greiman and install the latest version. Users who prefer to manually install the library can get it from the GitHub Repository or download the .ZIP by clicking the button below:</p> Bill Greiman's SdFat Arduino Library (ZIP) <p>Note</p> <p>At the time of writing, SdFat by Bill Greiman v2.2.3 worked with the SparkFun Thing Plus - NORA-W306.</p> <p>Note</p> <p>We recommend using some of the built-in libraries for the u-blox NORA-W306 as well after installing the board add-ons: File &gt; Examples &gt; Examples for SparkFun Thing Plus NORA-W306 (RTL8720DF) . Certain examples like the AmebaWS2812B were written specifically for the NORA-W306 architecture.</p> <p> More Arduino Examples! </p>"},{"location":"single_page/#arduino","title":"Arduino","text":""},{"location":"single_page/#example-1-blink","title":"Example 1 - Blink","text":"<p>Now that we have our board add-on installed, we can get started playing around with the development board. For the scope of this tutorial, we will highlight a few of the features on the board. From there we will be able to build our own custom code to integrate the development board into a project.</p> <p>In this example, we will blink the LED that is built into the SparkFun Thing Plus NORA-W306.</p>"},{"location":"single_page/#hardware-hookup_1","title":"Hardware Hookup","text":"<p>The connection is the same as explained earlier in the tutorial. Connect the USB cable to the SparkFun Thing Plus NORA-W306. Of course, make sure to connect the other end to your computer.</p> USB Cable inserted into Thing Plus NORA-W306"},{"location":"single_page/#arduino-code","title":"Arduino Code","text":"<p>Let's upload a sketch to the board. This example is the basic Arduino blink example. Note that we specify pin <code>18</code> instead of using the macro called <code>LED_BUILTIN</code>.</p> <p>Copy and paste the following code in the Arduino IDE. Select the correct board definition from the menu (in this case, Tools &gt; Board &gt; Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz) &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF). Then select the correct COM port that the board enumerated to (in this case, it was COM13). Hit upload button.</p> <pre><code>/*\n  Blink\n  Turns on an LED on for one second, then off for one second, repeatedly.\n\n  This example code is in the public domain.\n */\n\n// Pin 18 has an LED connected on most Arduino boards.\n// give it a name:\nint led = 18; //LED is connected to pin 18 on the SparkFun Thing Plus NORA-W306\n\n//NOTE: You can also use LED_BUILTIN.\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // initialize the digital pin as an output.\n  pinMode(led, OUTPUT);\n}\n\n// the loop routine runs over and over again forever:\nvoid loop() {\n  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)\n  delay(1000);               // wait for a second\n  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW\n  delay(1000);               // wait for a second\n}\n</code></pre> <p>Note</p> <p>Note: You can also use the macro for the LED by using <code>LED_BUILTIN</code>. The code in the built-in Arduino examples will function the same as well!</p> <p>Once uploaded, check the LED labeled as 18 on the board. It should be blinking on and off every second! Sweet!</p> SparkFun Thing Plus NORA-W306 User LED On"},{"location":"single_page/#example-2-button","title":"Example 2: Button","text":"<p>--8&lt;-- \"./docs/arduino_example_2_button.md</p>"},{"location":"single_page/#example-3-scanning-wifi-networks","title":"Example 3 - Scanning WiFi Networks","text":"<p>In this example, we will scan for WiFi networks in the area.</p>"},{"location":"single_page/#hardware-hookup_2","title":"Hardware Hookup","text":"<p>The connection is the same as explained earlier in the tutorial. Connect the USB cable to the SparkFun Thing Plus NORA-W306. Of course, make sure to connect the other end to your computer. You will also need a wireless router capable of 2.4GHz and 5GHz.</p> USB Cable inserted into Thing Plus NORA-W306"},{"location":"single_page/#arduino-code_1","title":"Arduino Code","text":"<p>Let's try to scan for some WiFi networks. You can find this example included after installing the board add-on. Head to File &gt; Examples &gt; Examples for SparkFun Thing Plus NORA-W306 (RTL8720DF) | WiFi &gt; ScanNetworks .</p> <p>You can also copy and paste the following code in the Arduino IDE. Select the correct board definition from the menu (in this case, Tools &gt; Board &gt; Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz) &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF)). Then select the correct COM port that the board enumerated to (in this case, it was COM13). Hit upload button.</p> <pre><code>/*\n This example prints MAC address, and\n scans for available Wifi networks.\n Every ten seconds, it scans again. It doesn't actually\n connect to any network, so no encryption scheme is specified.\n\n created 13 July 2010\n by dlf (Metodo2 srl)\n modified 21 Junn 2012\n by Tom Igoe and Jaymes Dec\n\n modified 08 May 2023\n by Realtek SG\n\n Example guide:\n https://www.amebaiot.com/en/amebad-arduino-scan-wifi/\n */\n\n#include &lt;WiFi.h&gt;\n\nint status = WL_IDLE_STATUS;    // Indicater of Wifi status\n\nvoid setup() {\n    //Initialize serial and wait for port to open:\n    Serial.begin(115200);\n    while (!Serial) {\n        ; // wait for serial port to connect. Needed for native USB port only\n    }\n\n    // check for WiFi status:\n    status = WiFi.status();\n    // Print WiFi MAC address:\n    printMacAddress();\n}\n\nvoid loop() {\n    // scan for existing networks:\n    Serial.println(\"Scanning available networks...\");\n    listNetworks();\n    delay(10000);\n}\n\nvoid printMacAddress() {\n    // print your MAC address:\n    byte mac[6];\n    WiFi.macAddress(mac);\n    Serial.print(\"MAC: \");\n    Serial.print(mac[0], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[1], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[2], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[3], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[4], HEX);\n    Serial.print(\":\");\n    Serial.println(mac[5], HEX);\n}\n\nvoid listNetworks() {\n    // scan for nearby networks:\n    Serial.println(\"** Scan Networks **\");\n    int numSsid = WiFi.scanNetworks();\n    if (numSsid == -1) {\n        Serial.println(\"Couldn't get a wifi connection\");\n        while (true);\n    }\n\n    // print the list of networks seen:\n    Serial.print(\"number of available networks:\");\n    Serial.println(numSsid);\n\n    // print the network number and name for each network found:\n    for (int thisNet = 0; thisNet &lt; numSsid; thisNet++) {\n        Serial.print(thisNet);\n        Serial.print(\") \");\n        Serial.print(WiFi.SSID(thisNet));\n        Serial.print(\"\\tSignal: \");\n        Serial.print(WiFi.RSSI(thisNet));\n        Serial.print(\" dBm\");\n        Serial.print(\"\\tEncryptionRaw: \");\n        printEncryptionTypeEx(WiFi.encryptionTypeEx(thisNet));\n        Serial.print(\"\\tEncryption: \");\n        printEncryptionType(WiFi.encryptionType(thisNet));\n    }\n}\n\nvoid printEncryptionTypeEx(uint32_t thisType) {\n    /*  Arduino wifi api use encryption type to mapping to security type.\n    *  This function demonstrate how to get more richful information of security type.\n    */\n    switch (thisType) {\n        case SECURITY_OPEN:\n            Serial.print(\"Open\");\n            break;\n        case SECURITY_WEP_PSK:\n            Serial.print(\"WEP\");\n            break;\n        case SECURITY_WPA_TKIP_PSK:\n            Serial.print(\"WPA TKIP\");\n            break;\n        case SECURITY_WPA_AES_PSK:\n            Serial.print(\"WPA AES\");\n            break;\n        case SECURITY_WPA2_AES_PSK:\n            Serial.print(\"WPA2 AES\");\n            break;\n        case SECURITY_WPA2_TKIP_PSK:\n            Serial.print(\"WPA2 TKIP\");\n            break;\n        case SECURITY_WPA2_MIXED_PSK:\n            Serial.print(\"WPA2 Mixed\");\n            break;\n        case SECURITY_WPA_WPA2_MIXED:\n            Serial.print(\"WPA/WPA2 AES\");\n            break;\n        case SECURITY_WPA3_AES_PSK:\n            Serial.print(\"WPA3 AES\");\n            break;\n        case SECURITY_WPA2_WPA3_MIXED:\n            Serial.print(\"WPA2/WPA3\");\n    }\n}\n\nvoid printEncryptionType(int thisType) {\n    // read the encryption type and print out the name:\n    switch (thisType) {\n        case ENC_TYPE_WEP:\n            Serial.println(\"WEP\");\n            break;\n        case ENC_TYPE_WPA:\n            Serial.println(\"WPA\");\n            break;\n        case ENC_TYPE_WPA2:\n            Serial.println(\"WPA2\");\n            break;\n        case ENC_TYPE_WPA3:\n            Serial.println(\"WPA3\");\n            break;\n        case ENC_TYPE_NONE:\n            Serial.println(\"None\");\n            break;\n        case ENC_TYPE_AUTO:\n            Serial.println(\"Auto\");\n            break;\n    }\n}\n</code></pre> <p>Open you Arduino Serial Monitor at 115200. The SparkFun Thing Plus NORA-W306 will begin scanning your area. Take note of the encryption type of the WiFi network that you are connecting to. In this case, I had set my home WiFi Router's 5GHz network name to \"SparkFun_Router_5GHz\" and it was using a WPA2 encryption (as highlighted in the Arduino Serial Monitor).</p> SparkFun Router 5GHz Highlighted Arduino Output"},{"location":"single_page/#example-4-connecting-to-a-wifi-network","title":"Example 4 - Connecting to a WiFi Network","text":"<p>In this example, we will connect to a 5GHz WiFi network.</p>"},{"location":"single_page/#hardware-hookup_3","title":"Hardware Hookup","text":"<p>The connection is the same as explained earlier in the tutorial. Connect the USB cable to the SparkFun Thing Plus NORA-W306 and the other end to your computer. Again, you will need a wireless router capable of 2.4GHz and 5GHz.</p> USB Cable inserted into Thing Plus NORA-W306"},{"location":"single_page/#arduino-code_2","title":"Arduino Code","text":"<p>Let's upload the sketch to connect to the 5GHz network in your area. From the menu, select the following: File &gt; Examples &gt; File &gt; Examples &gt; Examples for SparkFun Thing Plus NORA-W306 (RTL8720DF) | WiFi &gt; ConnectWithWiFi &gt; ConnectWithWPA. Depending on your encryption, you may select a different example.</p> <p>Note</p> <p>Depending on your encryption, you may select a different Arduino sketch to connect to the WiFi. Based on the previous example, the connection used WPA so we selected the ConnectWithWPA.ino example.</p> <p>Or you can copy and paste the following code in the Arduino IDE.</p> <pre><code>/*\n This example connects to an unencrypted Wifi network.\n Then it prints the MAC address,\n the IP address obtained, and other network details.\n\n created 13 July 2010\n by dlf (Metodo2 srl)\n modified 31 May 2012\n by Tom Igoe\n\n modified 08 May 2023\n by Realtek SG\n\n Example guide:\n https://www.amebaiot.com/en/amebad-arduino-connect-wifi/\n */\n\n#include &lt;WiFi.h&gt;\n\n// Set if user wants to key in ssid/pwd manually during operation\n//#define MANUAL_INPUT\n\n#ifdef MANUAL_INPUT  // Initialise ssid string, pwd string, and serial_in object\n// Initialise strings\nString str_ssid, str_pass;\n#endif\n\n// If you are connecting to an iPhone WiFi hotspot, the default SSID uses Unicode (U+2019) Right Single Quotation Mark instead of ASCII apostrophe\n// Modify the \"Your Name\" section in the SSID below to connect to an iPhone using a default SSID style\n// char ssid[] = \"Your Name\\xE2\\x80\\x99s iPhone\";\n\n// UTF-8 encoding can also be used for SSID with emoji characters\n// Emoji characters can be converted into UTF-8 at https://mothereff.in/utf-8\n// char ssid[] = \"\\xe2\\x9c\\x8c\\xef\\xb8\\x8f Ameba \\xe2\\x9c\\x8c\\xef\\xb8\\x8f\";\n\nchar ssid[] = \"Network_SSID\";       // your network SSID (name)\nchar pass[] = \"Password\";           // your network password\nint status = WL_IDLE_STATUS;        // Indicater of Wifi status\n\nvoid setup() {\n    //Initialize serial and wait for port to open:\n    Serial.begin(115200);\n    while (!Serial) {\n        ; // wait for serial port to connect. Needed for native USB port only\n    }\n\n    // attempt to connect to Wifi network:\n    while (status != WL_CONNECTED) {\n#ifdef MANUAL_INPUT\n        Serial.println(\"Enter your ssid\");\n        while (Serial.available() == 0) {}\n            str_ssid = Serial.readString();\n            str_ssid.trim();\n            Serial.print(\"SSID entered: \");\n            Serial.println(str_ssid);\n\n        Serial.println(\"Enter your password\");\n        while (Serial.available() == 0) {}\n        str_pass = Serial.readString();\n        str_pass.trim();\n            if (str_pass.length() != 0) { // user has entered data\n                while (str_pass.length() &lt;8 ) { // to catch pwd&lt;8 exception\n                    Serial.println(\"Password cannot be less than 8 characters! Try again\");\n                    while (Serial.available() == 0) {}\n                    str_pass = Serial.readString();\n                    str_pass.trim();\n                }\n                    Serial.print(\"Password entered: \");\n                    Serial.println(str_pass);\n            }\n#endif\n        Serial.print(\"Attempting to connect to WPA SSID: \");\n\n#ifndef MANUAL_INPUT\n        Serial.println(ssid);\n        // Connect to WPA/WPA2 network:\n        status = WiFi.begin(ssid, pass);\n#else\n        char ssid_cust[str_ssid.length() + 1];\n        char pass_cust[str_pass.length() + 1];\n        strcpy(ssid_cust, str_ssid.c_str());\n        strcpy(pass_cust, str_pass.c_str());\n        Serial.println(str_ssid.c_str());\n        status = WiFi.begin(ssid_cust, pass_cust);\n        str_ssid = str_pass = \"\";\n#endif\n        // wait 10 seconds for connection:\n        delay(10000);\n    }\n\n    // you're connected now, so print out the data:\n    Serial.println();\n    Serial.print(\"You're connected to the network\");\n    printCurrentNet();\n    printWifiData();\n}\n\nvoid loop() {\n    // check the network connection once every 10 seconds:\n    delay(10000);\n    printCurrentNet();\n}\n\nvoid printWifiData() {\n    // print your WiFi IP address:\n    IPAddress ip = WiFi.localIP();\n    Serial.print(\"IP Address: \");\n    Serial.println(ip);\n    Serial.println(ip);\n\n    // print your MAC address:\n    byte mac[6];\n    WiFi.macAddress(mac);\n    Serial.print(\"MAC address: \");\n    Serial.print(mac[0], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[1], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[2], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[3], HEX);\n    Serial.print(\":\");\n    Serial.print(mac[4], HEX);\n    Serial.print(\":\");\n    Serial.println(mac[5], HEX);\n}\n\nvoid printCurrentNet() {\n    // print the SSID of the network you're attached to:\n    Serial.print(\"SSID: \");\n    Serial.println(WiFi.SSID());\n\n    // print the MAC address of the router you're attached to:\n    byte bssid[6];\n    WiFi.BSSID(bssid);\n    Serial.print(\"BSSID: \");\n    Serial.print(bssid[5], HEX);\n    Serial.print(\":\");\n    Serial.print(bssid[4], HEX);\n    Serial.print(\":\");\n    Serial.print(bssid[3], HEX);\n    Serial.print(\":\");\n    Serial.print(bssid[2], HEX);\n    Serial.print(\":\");\n    Serial.print(bssid[1], HEX);\n    Serial.print(\":\");\n    Serial.println(bssid[0], HEX);\n\n    // print the received signal strength:\n    long rssi = WiFi.RSSI();\n    Serial.print(\"signal strength (RSSI):\");\n    Serial.println(rssi);\n\n    // print the encryption type:\n    byte encryption = WiFi.encryptionType();\n    Serial.print(\"Encryption Type:\");\n    Serial.println(encryption, HEX);\n    Serial.println();\n}\n</code></pre> <p>Then adjust the arrays that holed the SSID (i.e. <code>yourNetwork</code>) and password  (<code>secretPassword</code>) based on your WiFi network's settings.</p> SSID Changed <p>Select the correct board definition from the menu (in this case, Tools &gt; Boards &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF)). Then select the correct COM port that the board enumerated to (in this case, it was COM13). Hit upload button.</p> <p>Open the Arduino Serial Monitor at 115200. The SparkFun Thing Plus NORA-W306 will attempt to connect to the network.</p> Serial Monitor attempting to connect to WiFi network <p>If all goes well, you should see some status outputs and message indicating that you are connected to your network! In this case, I had the following message:</p> <pre>\n    <code>You're connected to the networkSSID: SparkFun_Router_5GHz</code>\n</pre> <p>The serial output will then continue outputting the status of the connection some of which include the SSID, signal strength (RSSI), and encryption type.  If you have admin privileges, you can check to see if the device is connected to the 5GHz WiFi network as well. Try connecting to a website and pulling the local time or weather in your area!</p>"},{"location":"single_page/#example-5a-bluetooth-uart-service","title":"Example 5a - Bluetooth UART Service","text":"<p>In the following two examples, we will connect two NORA-W306 development boards  via Bluetooth and send serial characters.</p>"},{"location":"single_page/#hardware-hookup_4","title":"Hardware Hookup","text":"<p>Connect the USB C cables to the boards and two different COM ports on your computer.</p> <p>Tip</p> <p>To keep track of which board that you are connecting to, use a sticky note and label the boards that you are using as the Service and Client.</p> USB Cable inserted into Thing Plus NORA-W306 <p>When connecting and disconnecting the boards from your computer, you will noticed that the COM port enumerates to a certain number from the menu Tools &gt; Port. Feel free to write down the COM port on the sticky note as well after uploading code.</p>"},{"location":"single_page/#arduino-code_3","title":"Arduino Code","text":"<p>Let's upload the sketch to send serial data between two SparkFun Thing Plus NORA-W306 boards wirelessly using the Bluetooth\u00ae Low Energy (BLE) feature. From the menu, select the following: File &gt; Examples &gt; File &gt; Examples &gt; Examples for SparkFun Thing Plus NORA-W306 (RTL8720DF) | AmebaBLE &gt; BLEUartService.</p> <p>Or you can copy and paste the following code in the Arduino IDE. Select the correct board definition from the menu (in this case, Tools &gt; Boards &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF)). Then select the correct COM port that the board enumerated to (in this case, it was COM13). Hit upload button.</p> <pre><code>/*\n\n Example guide:\n https://www.amebaiot.com/en/amebad-arduino-ble-uart-service/\n */\n\n#include \"BLEDevice.h\"\n\n#define UART_SERVICE_UUID      \"6E400001-B5A3-F393-E0A9-E50E24DCCA9E\"\n#define CHARACTERISTIC_UUID_RX \"6E400002-B5A3-F393-E0A9-E50E24DCCA9E\"\n#define CHARACTERISTIC_UUID_TX \"6E400003-B5A3-F393-E0A9-E50E24DCCA9E\"\n\n#define STRING_BUF_SIZE 100\n\nBLEService UartService(UART_SERVICE_UUID);\nBLECharacteristic Rx(CHARACTERISTIC_UUID_RX);\nBLECharacteristic Tx(CHARACTERISTIC_UUID_TX);\nBLEAdvertData advdata;\nBLEAdvertData scndata;\nbool notify = false;\n\nvoid readCB (BLECharacteristic* chr, uint8_t connID) {\n    Serial.print(\"Characteristic \");\n    Serial.print(chr-&gt;getUUID().str());\n    Serial.print(\" read by connection \");\n    Serial.println(connID);\n}\n\nvoid writeCB (BLECharacteristic* chr, uint8_t connID) {\n    Serial.print(\"Characteristic \");\n    Serial.print(chr-&gt;getUUID().str());\n    Serial.print(\" write by connection \");\n    Serial.println(connID);\n    if (chr-&gt;getDataLen() &gt; 0) {\n        Serial.print(\"Received string: \");\n        Serial.print(chr-&gt;readString());\n        Serial.println();\n    }\n}\n\nvoid notifCB(BLECharacteristic* chr, uint8_t connID, uint16_t cccd) {\n    if (cccd &amp; GATT_CLIENT_CHAR_CONFIG_NOTIFY) {\n        //printf(\"Notifications enabled on Characteristic %s for connection %d \\n\", chr-&gt;getUUID().str(), connID);\n        Serial.print(\"Notifications enabled on Characteristic\");\n        notify = true;\n    } else {\n        //printf(\"Notifications disabled on Characteristic %s for connection %d \\n\", chr-&gt;getUUID().str(), connID);\n        Serial.print(\"Notifications disabled on Characteristic\");\n        notify = false;\n    }\n    Serial.print(chr-&gt;getUUID().str());\n    Serial.print(\" for connection\");\n    Serial.println(connID);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n\n    advdata.addFlags(GAP_ADTYPE_FLAGS_LIMITED | GAP_ADTYPE_FLAGS_BREDR_NOT_SUPPORTED);\n    advdata.addCompleteName(\"AMEBA_BLE_DEV\");\n    scndata.addCompleteServices(BLEUUID(UART_SERVICE_UUID));\n\n    Rx.setWriteProperty(true);\n    Rx.setWritePermissions(GATT_PERM_WRITE);\n    Rx.setWriteCallback(writeCB);\n    Rx.setBufferLen(STRING_BUF_SIZE);\n    Tx.setReadProperty(true);\n    Tx.setReadPermissions(GATT_PERM_READ);\n    Tx.setReadCallback(readCB);\n    Tx.setNotifyProperty(true);\n    Tx.setCCCDCallback(notifCB);\n    Tx.setBufferLen(STRING_BUF_SIZE);\n\n    UartService.addCharacteristic(Rx);\n    UartService.addCharacteristic(Tx);\n\n    BLE.init();\n    BLE.configAdvert()-&gt;setAdvData(advdata);\n    BLE.configAdvert()-&gt;setScanRspData(scndata);\n    BLE.configServer(1);\n    BLE.addService(UartService);\n\n    BLE.beginPeripheral();\n}\n\nvoid loop() {\n    if (Serial.available()) {\n        Tx.writeString(Serial.readString());\n        if (BLE.connected(0) &amp;&amp; notify) {\n            Tx.notify(0);\n        }\n    }\n    delay(100);\n}\n</code></pre> <p>When finished uploading, head to the next section to upload code to a second SparkFun Thing Plus NORA-W306 board.</p>"},{"location":"single_page/#example-5b-bluetooth-uart-client","title":"Example 5b - Bluetooth UART Client","text":"<p>We will upload code for the Bluetooth UART client in this example. Then we will send characters between two serial terminals.</p>"},{"location":"single_page/#hardware-hookup_5","title":"Hardware Hookup","text":"<p>Connect the USB C cables to the boards and two different COM ports on your computer.</p> <p>Tip</p> <p>To keep track of which board that you are connecting to, use a sticky note and label the boards that you are using as the Service and Client.</p> USB Cable inserted into Thing Plus NORA-W306"},{"location":"single_page/#arduino-code_4","title":"Arduino Code","text":"<p>Let's upload the corresponding sketch to send serial data between two SparkFun Thing Plus NORA-W306 boards wirelessly using the Bluetooth\u00ae Low Energy (BLE) feature. From the menu, select the following: File &gt; Examples &gt; File &gt; Examples &gt; Examples for SparkFun Thing Plus NORA-W306 (RTL8720DF) | AmebaBLE &gt; BLEUartClient.</p> <p>Or you can copy and paste the following code in the Arduino IDE. Select the correct board definition from the menu (in this case, Tools &gt; Boards &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF)). Then select the correct COM port that the board enumerated to (in this case, it was COM22). Hit upload button.</p> <pre><code>/*\n\n Example guide:\n https://www.amebaiot.com/en/amebad-arduino-ble-uart/\n */\n\n#include \"BLEDevice.h\"\n\n#define UART_SERVICE_UUID      \"6E400001-B5A3-F393-E0A9-E50E24DCCA9E\"\n#define CHARACTERISTIC_UUID_RX \"6E400002-B5A3-F393-E0A9-E50E24DCCA9E\"\n#define CHARACTERISTIC_UUID_TX \"6E400003-B5A3-F393-E0A9-E50E24DCCA9E\"\n\n#define STRING_BUF_SIZE 100\n\nBLEAdvertData foundDevice;\nBLEAdvertData targetDevice;\nBLEClient* client;\nBLERemoteService* UartService;\nBLERemoteCharacteristic* Rx;\nBLERemoteCharacteristic* Tx;\n\nvoid scanCB(T_LE_CB_DATA* p_data) {\n    foundDevice.parseScanInfo(p_data);\n    if (foundDevice.hasName()) {\n        if (foundDevice.getName() == String(\"AMEBA_BLE_DEV\")) {\n            Serial.print(\"Found Ameba BLE Device at address \");\n            Serial.println(foundDevice.getAddr().str());\n            targetDevice = foundDevice;\n        }\n    }\n}\n\nvoid notificationCB (BLERemoteCharacteristic* chr, uint8_t* data, uint16_t len) {\n    char msg[len+1] = {0};\n    memcpy(msg, data, len);\n    Serial.print(\"Notification received for chr UUID: \");\n    Serial.println(chr-&gt;getUUID().str());\n    Serial.print(\"Received string: \");\n    Serial.println(String(msg));\n}\n\nvoid setup() {\n    Serial.begin(115200);\n\n    BLE.init();\n    BLE.setScanCallback(scanCB);\n    BLE.beginCentral(1);\n\n    BLE.configScan()-&gt;startScan(2000);\n    BLE.configConnection()-&gt;connect(targetDevice, 2000);\n    delay(2000);\n    int8_t connID = BLE.configConnection()-&gt;getConnId(targetDevice);\n    if (!BLE.connected(connID)) {\n        Serial.println(\"BLE not connected\");\n    } else {\n        BLE.configClient();\n        client = BLE.addClient(connID);\n        client-&gt;discoverServices();\n        Serial.print(\"Discovering services of connected device\");\n        do {\n            Serial.print(\".\");\n            delay(1000);\n        } while (!(client-&gt;discoveryDone()));\n        Serial.println();\n\n        UartService = client-&gt;getService(UART_SERVICE_UUID);\n        if (UartService != nullptr) {\n            Tx = UartService-&gt;getCharacteristic(CHARACTERISTIC_UUID_TX);\n            if (Tx != nullptr) {\n                Serial.println(\"TX characteristic found\");\n                Tx-&gt;setBufferLen(STRING_BUF_SIZE);\n                Tx-&gt;setNotifyCallback(notificationCB);\n                Tx-&gt;enableNotifyIndicate();\n            }\n            Rx = UartService-&gt;getCharacteristic(CHARACTERISTIC_UUID_RX);\n            if (Rx != nullptr) {\n                Serial.println(\"RX characteristic found\");\n                Rx-&gt;setBufferLen(STRING_BUF_SIZE);\n            }\n        }\n    }\n}\n\nvoid loop() {\n    if (Serial.available()) {\n        Rx-&gt;writeString(Serial.readString());\n    }\n    delay(100);\n}\n</code></pre> <p>To test, open the Arduino Serial Monitor for the client device on its respective COM port at 115200. Then open a second serial terminal (in this case we used TeraTerm) for the previous service device on its respective COM port at 115200. Type some characters and hit Send button from the client device. You should see the same characters received on the service device! Then try typing messages from the service to the client. Again, you should see the same characters on the other end. You may need to turn on the local echo depending on the terminal window that you are using.</p> BLE UART Service via Tera Term BLE UART Client via Arduino Serial Monitor"},{"location":"single_page/#example-6-microsd-card","title":"Example 6 - MicroSD Card","text":"<p>In this example, we will write some text to a microSD card and read the contents of the text file for verification.</p>"},{"location":"single_page/#hardware-hookup_6","title":"Hardware Hookup","text":"<p>Make sure to insert a microSD card into the microSD card socket on the back of the board.</p> MicroSD Card in Socket <p>When ready, connect the board to your computer with the USB C cable.</p>"},{"location":"single_page/#arduino-library","title":"Arduino Library","text":"<p>If you have not already, make sure to install the following library as explained earlier. Keep in mind there is more than one SdFat Arduino Library. We recommend using the SdFat Arduino Library by Bill Greiman.</p> <ul> <li>SdFat</li> </ul>"},{"location":"single_page/#arduino-code_5","title":"Arduino Code","text":"<p>Let's check your microSD card, write some text to a fill, and read hte contents of the file for verification</p> <p>Copy and paste the following code in the Arduino IDE. Select the correct board definition from the menu (in this case, Tools &gt; Boards &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF)). Then select the correct COM port that the board enumerated to (in this case, it was COM13). Hit upload button.</p> <pre><code>/*\nSparkFun Electronics\n7/17/2024\n\n\nSD card example for the SparkFun Thing Plus NORA-W306\n\n\nNote, the SparkFun Thing Plus NORA-W306 does not use the SDIO hardware peripheral.\nIt utilizes SPI0 to communicate with the uSD card.\n\n\nUsing sdFAT and the onboard uSD socket (SPI0), this program attempts to:\n\n  1. Initialize an SD card and analyze its structure.\n\n\n  2. Create a file on the SD card and write a string to it.\n\n\n  3. Open the file and print the contents to the serial monitor.\n\n\nHardware Hookup and Instructions:\n  Insert an SD card into the SD card slot on the NORA-W306.\n  Connect the NORA-W306 to your computer using a USB-C cable.\n  Upload this code to the NORA-W306.\n  Open the serial monitor to see the results.\n\n\nSoftware versions used in this example:\n  Arduino IDE 2.3.2\n  usdFAT by Bill Greiman, Arduino Library Version 2.2.3\n    (https://github.com/greiman/SdFat)\n  Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz) by Realtek Version 3.1.8\n    (https://github.com/ambiot/ambd_arduino)\n    (https://raw.githubusercontent.com/ambiot/ambd_arduino/dev/Arduino_package/package_realtek_amebad_early_index.json)\n\n\nOriginal code is from the following two examples in the SdFat library:\n  SdInfo - Program to read and display SD card information\n    -MIT License, Copyright (c) 2011..2020 Bill Greiman\n  examplesV1/ReadWrite - Program to test read and write functions\n    -Public Domain, created Nov 2010 by David A. Mellis, modified 9 Apr 2012 by Tom Igoe\n\n\nMIT License\n\n\nCopyright (c) 2024 SparkFun Electronics\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in the\nSoftware without restriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\nSoftware, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n#include \"SdFat.h\"\n#include \"sdios.h\"\n\n\nFile myFile;\n\n\n/*\n  Set DISABLE_CS_PIN to disable a second SPI device.\n  For example, with the Ethernet shield, set DISABLE_CS_PIN\n  to 10 to disable the Ethernet controller.\n*/\nconst int8_t DISABLE_CS_PIN = -1;\n/*\n  Change the value of SD_CS_PIN if you are using SPI\n  and your hardware does not use the default value, SS.\n  Common values are:\n  Arduino Ethernet shield: pin 4\n  Sparkfun SD shield: pin 8\n  Adafruit SD shields and modules: pin 10\n  SparkFun Thing Plus NORA-W306: Arduino pin 4 (aka SS/PB_21/SPI0_CS)\n*/\n// SDCARD_SS_PIN is defined for the built-in SD on some boards.\n#ifndef SDCARD_SS_PIN\nconst uint8_t SD_CS_PIN = SS;\n#else   // SDCARD_SS_PIN\nconst uint8_t SD_CS_PIN = SDCARD_SS_PIN;\n#endif  // SDCARD_SS_PIN\n\n\n// Try to select the best SD card configuration.\n#if HAS_SDIO_CLASS\n#define SD_CONFIG SdioConfig(FIFO_SDIO)\n#elif ENABLE_DEDICATED_SPI\n#define SD_CONFIG SdSpiConfig(SD_CS_PIN, DEDICATED_SPI, SD_SCK_MHZ(16))\n#else  // HAS_SDIO_CLASS\n#define SD_CONFIG SdSpiConfig(SD_CS_PIN, SHARED_SPI, SD_SCK_MHZ(16))\n#endif  // HAS_SDIO_CLASS\n\n\n//------------------------------------------------------------------------------\nSdFs sd;\ncid_t cid;\ncsd_t csd;\nscr_t scr;\nuint8_t cmd6Data[64];\nuint32_t eraseSize;\nuint32_t ocr;\nstatic ArduinoOutStream cout(Serial);\n//------------------------------------------------------------------------------\nvoid cidDmp() {\n  cout &lt;&lt; F(\"\\nManufacturer ID: \");\n  cout &lt;&lt; uppercase &lt;&lt; showbase &lt;&lt; hex &lt;&lt; int(cid.mid) &lt;&lt; dec &lt;&lt; endl;\n  cout &lt;&lt; F(\"OEM ID: \") &lt;&lt; cid.oid[0] &lt;&lt; cid.oid[1] &lt;&lt; endl;\n  cout &lt;&lt; F(\"Product: \");\n  for (uint8_t i = 0; i &lt; 5; i++) {\n    cout &lt;&lt; cid.pnm[i];\n  }\n  cout &lt;&lt; F(\"\\nRevision: \") &lt;&lt; cid.prvN() &lt;&lt; '.' &lt;&lt; cid.prvM() &lt;&lt; endl;\n  cout &lt;&lt; F(\"Serial number: \") &lt;&lt; hex &lt;&lt; cid.psn() &lt;&lt; dec &lt;&lt; endl;\n  cout &lt;&lt; F(\"Manufacturing date: \");\n  cout &lt;&lt; cid.mdtMonth() &lt;&lt; '/' &lt;&lt; cid.mdtYear() &lt;&lt; endl;\n  cout &lt;&lt; endl;\n}\n//------------------------------------------------------------------------------\nvoid clearSerialInput() {\n  uint32_t m = micros();\n  do {\n    if (Serial.read() &gt;= 0) {\n      m = micros();\n    }\n  } while (micros() - m &lt; 10000);\n}\n//------------------------------------------------------------------------------\nvoid csdDmp() {\n  eraseSize = csd.eraseSize();\n  cout &lt;&lt; F(\"cardSize: \") &lt;&lt; 0.000512 * csd.capacity();\n  cout &lt;&lt; F(\" MB (MB = 1,000,000 bytes)\\n\");\n\n\n\n\n  cout &lt;&lt; F(\"flashEraseSize: \") &lt;&lt; int(eraseSize) &lt;&lt; F(\" blocks\\n\");\n  cout &lt;&lt; F(\"eraseSingleBlock: \");\n  if (csd.eraseSingleBlock()) {\n    cout &lt;&lt; F(\"true\\n\");\n  } else {\n    cout &lt;&lt; F(\"false\\n\");\n  }\n  cout &lt;&lt; F(\"dataAfterErase: \");\n  if (scr.dataAfterErase()) {\n    cout &lt;&lt; F(\"ones\\n\");\n  } else {\n    cout &lt;&lt; F(\"zeros\\n\");\n  }\n}\n//------------------------------------------------------------------------------\nvoid errorPrint() {\n  if (sd.sdErrorCode()) {\n    cout &lt;&lt; F(\"SD errorCode: \") &lt;&lt; hex &lt;&lt; showbase;\n    printSdErrorSymbol(&amp;Serial, sd.sdErrorCode());\n    cout &lt;&lt; F(\" = \") &lt;&lt; int(sd.sdErrorCode()) &lt;&lt; endl;\n    cout &lt;&lt; F(\"SD errorData = \") &lt;&lt; int(sd.sdErrorData()) &lt;&lt; dec &lt;&lt; endl;\n  }\n}\n//------------------------------------------------------------------------------\nbool mbrDmp() {\n  MbrSector_t mbr;\n  bool valid = true;\n  if (!sd.card()-&gt;readSector(0, (uint8_t *)&amp;mbr)) {\n    cout &lt;&lt; F(\"\\nread MBR failed.\\n\");\n    errorPrint();\n    return false;\n  }\n  cout &lt;&lt; F(\"\\nSD Partition Table\\n\");\n  cout &lt;&lt; F(\"part,boot,bgnCHS[3],type,endCHS[3],start,length\\n\");\n  for (uint8_t ip = 1; ip &lt; 5; ip++) {\n    MbrPart_t *pt = &amp;mbr.part[ip - 1];\n    if ((pt-&gt;boot != 0 &amp;&amp; pt-&gt;boot != 0X80) || getLe32(pt-&gt;relativeSectors) &gt; csd.capacity()) {\n      valid = false;\n    }\n    cout &lt;&lt; int(ip) &lt;&lt; ',' &lt;&lt; uppercase &lt;&lt; showbase &lt;&lt; hex;\n    cout &lt;&lt; int(pt-&gt;boot) &lt;&lt; ',';\n    for (int i = 0; i &lt; 3; i++) {\n      cout &lt;&lt; int(pt-&gt;beginCHS[i]) &lt;&lt; ',';\n    }\n    cout &lt;&lt; int(pt-&gt;type) &lt;&lt; ',';\n    for (int i = 0; i &lt; 3; i++) {\n      cout &lt;&lt; int(pt-&gt;endCHS[i]) &lt;&lt; ',';\n    }\n    cout &lt;&lt; dec &lt;&lt; getLe32(pt-&gt;relativeSectors) &lt;&lt; ',';\n    cout &lt;&lt; getLe32(pt-&gt;totalSectors) &lt;&lt; endl;\n  }\n  if (!valid) {\n    cout &lt;&lt; F(\"\\nMBR not valid, assuming Super Floppy format.\\n\");\n  }\n  return true;\n}\n//------------------------------------------------------------------------------\nvoid dmpVol() {\n  cout &lt;&lt; F(\"\\nScanning FAT, please wait.\\n\");\n  int32_t freeClusterCount = sd.freeClusterCount();\n  if (sd.fatType() &lt;= 32) {\n    cout &lt;&lt; F(\"\\nVolume is FAT\") &lt;&lt; int(sd.fatType()) &lt;&lt; endl;\n  } else {\n    cout &lt;&lt; F(\"\\nVolume is exFAT\\n\");\n  }\n  cout &lt;&lt; F(\"sectorsPerCluster: \") &lt;&lt; sd.sectorsPerCluster() &lt;&lt; endl;\n  cout &lt;&lt; F(\"fatStartSector:    \") &lt;&lt; sd.fatStartSector() &lt;&lt; endl;\n  cout &lt;&lt; F(\"dataStartSector:   \") &lt;&lt; sd.dataStartSector() &lt;&lt; endl;\n  cout &lt;&lt; F(\"clusterCount:      \") &lt;&lt; sd.clusterCount() &lt;&lt; endl;\n  cout &lt;&lt; F(\"freeClusterCount:  \");\n  if (freeClusterCount &gt;= 0) {\n    cout &lt;&lt; freeClusterCount &lt;&lt; endl;\n  } else {\n    cout &lt;&lt; F(\"failed\\n\");\n    errorPrint();\n  }\n}\n//------------------------------------------------------------------------------\nvoid printCardType() {\n  cout &lt;&lt; F(\"\\nCard type: \");\n  switch (sd.card()-&gt;type()) {\n    case SD_CARD_TYPE_SD1:\n      cout &lt;&lt; F(\"SD1\\n\");\n      break;\n    case SD_CARD_TYPE_SD2:\n      cout &lt;&lt; F(\"SD2\\n\");\n      break;\n    case SD_CARD_TYPE_SDHC:\n      if (csd.capacity() &lt; 70000000) {\n        cout &lt;&lt; F(\"SDHC\\n\");\n      } else {\n        cout &lt;&lt; F(\"SDXC\\n\");\n      }\n      break;\n    default:\n      cout &lt;&lt; F(\"Unknown\\n\");\n  }\n}\n//------------------------------------------------------------------------------\nvoid printConfig(SdSpiConfig config) {\n  if (DISABLE_CS_PIN &lt; 0) {\n    cout &lt;&lt; F(\n      \"\\nAssuming the SD is the only SPI device.\\n\"\n      \"Edit DISABLE_CS_PIN to disable an SPI device.\\n\");\n  } else {\n    cout &lt;&lt; F(\"\\nDisabling SPI device on pin \");\n    cout &lt;&lt; int(DISABLE_CS_PIN) &lt;&lt; endl;\n    pinMode(DISABLE_CS_PIN, OUTPUT);\n    digitalWrite(DISABLE_CS_PIN, HIGH);\n  }\n  cout &lt;&lt; F(\"\\nAssuming the SD chip select pin is: \") &lt;&lt; int(config.csPin);\n  cout &lt;&lt; F(\"\\nEdit SD_CS_PIN to change the SD chip select pin.\\n\");\n}\n//------------------------------------------------------------------------------\nvoid printConfig(SdioConfig config) {\n  (void)config;\n  cout &lt;&lt; F(\"Assuming an SDIO interface.\\n\");\n}\n//-----------------------------------------------------------------------------\nvoid setup() {\n  Serial.begin(9600);\n  // Wait for USB Serial\n  while (!Serial) {\n    yield();\n  }\n  cout &lt;&lt; F(\"SdFat version: \") &lt;&lt; SD_FAT_VERSION_STR &lt;&lt; endl;\n  printConfig(SD_CONFIG);\n}\n//------------------------------------------------------------------------------\nvoid loop() {\n  // Read any existing Serial data.\n  clearSerialInput();\n\n\n  // F stores strings in flash to save RAM\n  cout &lt;&lt; F(\"\\ntype any character to start\\n\");\n  while (!Serial.available()) {\n    yield();\n  }\n  uint32_t t = millis();\n  if (!sd.cardBegin(SD_CONFIG)) {\n    cout &lt;&lt; F(\n      \"\\nSD initialization failed.\\n\"\n      \"Do not reformat the card!\\n\"\n      \"Is the card correctly inserted?\\n\"\n      \"Is there a wiring/soldering problem?\\n\");\n    if (isSpi(SD_CONFIG)) {\n      cout &lt;&lt; F(\n        \"Is SD_CS_PIN set to the correct value?\\n\"\n        \"Does another SPI device need to be disabled?\\n\");\n    }\n    errorPrint();\n    return;\n  }\n  t = millis() - t;\n  cout &lt;&lt; F(\"init time: \") &lt;&lt; dec &lt;&lt; t &lt;&lt; \" ms\" &lt;&lt; endl;\n\n\n  if (!sd.card()-&gt;readCID(&amp;cid) || !sd.card()-&gt;readCSD(&amp;csd) || !sd.card()-&gt;readOCR(&amp;ocr) || !sd.card()-&gt;readSCR(&amp;scr)) {\n    cout &lt;&lt; F(\"readInfo failed\\n\");\n    errorPrint();\n    return;\n  }\n  printCardType();\n  cout &lt;&lt; F(\"sdSpecVer: \") &lt;&lt; 0.01 * scr.sdSpecVer() &lt;&lt; endl;\n  cout &lt;&lt; F(\"HighSpeedMode: \");\n  if (scr.sdSpecVer() &amp;&amp; sd.card()-&gt;cardCMD6(0X00FFFFFF, cmd6Data) &amp;&amp; (2 &amp; cmd6Data[13])) {\n    cout &lt;&lt; F(\"true\\n\");\n  } else {\n    cout &lt;&lt; F(\"false\\n\");\n  }\n  cidDmp();\n  csdDmp();\n  cout &lt;&lt; F(\"\\nOCR: \") &lt;&lt; uppercase &lt;&lt; showbase;\n  cout &lt;&lt; hex &lt;&lt; ocr &lt;&lt; dec &lt;&lt; endl;\n  if (!mbrDmp()) {\n    return;\n  }\n  if (!sd.volumeBegin()) {\n    cout &lt;&lt; F(\"\\nvolumeBegin failed. Is the card formatted?\\n\");\n    errorPrint();\n    return;\n  }\n  dmpVol();\n  test();\n}\n//------------------------------------------------------------------------------\nvoid test() {\n  // open the file. note that only one file can be open at a time,\n  // so you have to close this one before opening another.\n  myFile = sd.open(\"test.txt\", FILE_WRITE);\n\n\n  // if the file opened okay, write to it:\n  if (myFile) {\n    Serial.print(\"Writing to test.txt...\");\n    myFile.println(\"testing 3,4,5 wahoo\");\n    // close the file:\n    myFile.close();\n    Serial.println(\"done.\");\n  } else {\n    // if the file didn't open, print an error:\n    Serial.println(\"error opening test.txt\");\n  }\n\n\n  // re-open the file for reading:\n  myFile = sd.open(\"test.txt\");\n  if (myFile) {\n    Serial.println(\"test.txt:\");\n\n\n\n\n    // read from the file until there's nothing else in it:\n    while (myFile.available()) {\n      Serial.write(myFile.read());\n    }\n    // close the file:\n    myFile.close();\n  } else {\n    // if the file didn't open, print an error:\n    Serial.println(\"error opening test.txt\");\n  }\n}\n</code></pre> <p>Open the Arduino Serial Monitor at 115200 baud. Send a character through the Arduino Serial Monitor. You should get a prompt in the Serial Monitor. Enter a chararacter (i.e. send s or any other keyboard character) to start. The example will then read the card. If the card is compatible, the output will provide information about the microSD card type, create a new file, write text to the file, and then close the file. The example will then re-open the file and read the contents of the file. You should see the following text in the file: \"testing 3,4,5 wahoo\". If the example code is run more than once, you may see the same text repeat a few times.</p> MicroSD Card Test Output <p>To open using the a file explorer, you can disconnect the SparkFun Thing Plus - NORA-W306, remove the microSD card, and connect it to a computer with a microSD card adapter. Once connected, you can open the test.txt file with a text editor to verify the text written in the file.</p> File Explorer Text Editor Verification"},{"location":"single_page/#example-7-deep-sleep-and-blink","title":"Example 7 - Deep Sleep and Blink","text":"<p>In this example, we will show how to set your board in deep sleep, blink the user LED as an indicator, and then go back into power saving mode.</p> <p>Note</p> <p>This is a modified example from the Realtek's Arduino example for Deep Sleep Mode.</p>"},{"location":"single_page/#hardware-hookup_7","title":"Hardware Hookup","text":"<p>For users interested in measuring the current draw via the MEAS jumper, you can cut the trace located on the back of the board. Power the board via USB or battery. Then place a multimeter set to measure current on the PTHs. This makes it easier to measure the current as opposed to measuring the current between the power source and connector.</p> <p>Note</p> <p>The MEAS jumper is before the XC6222 3.3V voltage regulator. For users that are connecting power to the 3V3 pin or Qwiic connector, you will need to place a multimeter between the regulated 3.3V power source and the board.</p> MEAS Jumper Modified <p>To upload code, connect the USB cable to the SparkFun Thing Plus NORA-W306. Of course, make sure to connect the other end to your computer.</p> USB Cable inserted into Thing Plus NORA-W306 <p>Tip</p> <p>Make sure to add a solder blob on the MEAS jumper when finished measuring. Users can also solder a 2-pin male header and shunt to the PTHs to easily remove/add the connection.</p>"},{"location":"single_page/#arduino-code_6","title":"Arduino Code","text":"<p>This example builds upon Realtek's deep sleep mode. Once the deep sleep modes are set up, the NORA-W306 goes into deep sleep. In this particular example, we will use the timer (i.e. <code>SET_DS_AON_TIMER_WAKEUP</code>) as the source. After 5 seconds, the board wakes up with the user LED also blinking five times before going back to deep sleep for 5 seconds.</p> <p>Note</p> <p>The serial UART is disabled to reduce amount the peripherals that are turned on. To save more power, you can cut the JP3 and PWR LED jumpers. There is also a fancy circuit to disable power to the CP2102 when there is no USB power. As an alternative to USB power, users can power the board with a LiPo battery.</p> <p>Copy and paste the following code in the Arduino IDE. Select your Board (in this case the SparkFun Thing Plus NORA-W306 (RTL8720DF)), and associated COM port (in this case COM13). Then hit the upload button.</p> <pre><code>/*\n* SparkFun Electronics\n* 7/17/2024\n*\n* SparkFun_ThingPlus_NORAW306_DeepSleepBlink.ino\n*\n* Deep Sleep mode example for the SparkFun Thing Plus NORA-W306\n*\n* This example demonstrates how to put the NORA-W306 into deep sleep mode and\n* wake it up using the AON timer (every 5 seconds).\n* When awake, the onboard LED will blink.\n* When asleep, the current consumption can be monitored using the MEAS jumper.\n*\n* Hardware Hookup and Instructions:\n*   Connect the NORA-W306 to your computer using a USB-C cable.\n*   Upload this code to the NORA-W306.\n*   To measure the low-power consumption of the NORA-W306, remove USB-C cable\n*   and utilize the MEAS jumper to measure the current consumption.\n*   \n* Software versions used in this example:\n*   Arduino IDE 2.3.2\n*   Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz) by Realtek Version 3.1.8\n*     (https://github.com/ambiot/ambd_arduino)\n*     (https://raw.githubusercontent.com/ambiot/ambd_arduino/dev/Arduino_package/package_realtek_amebad_early_index.json)\n*\n* Original code is from the following example in the RealTek Ameba Arduino package:\n*  Examples -&gt; AmebaPowerSave -&gt; DeepSleepMode.ino\n*\n* MIT License\n*\n* Copyright (c) 2024 SparkFun Electronics\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy of\n* this software and associated documentation files (the \"Software\"), to deal in the\n* Software without restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n* PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#include &lt;PowerSave.h&gt;\n\n//SET_DS_AON_TIMER_WAKEUP\n//SET_DS_RTC_WAKEUP\n//For AMB21/22 only the AON GPIO pins listed below should be selected\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 16\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 17\n    //SET_AON_GPIO_WAKEUP_PA21          // pin 26\n    //SET_AON_GPIO_WAKEUP_PA20          // pin 27\n    //SET_AON_GPIO_WAKEUP_PA19          // pin 28\n//For AMB23 only the AON GPIO pins listed below should be selected\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 9\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 10\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 11\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 12\n    //SET_AON_GPIO_WAKEUP_PA16          // pin 13\n    //SET_AON_GPIO_WAKEUP_PA18          // pin 15\n    //SET_AON_GPIO_WAKEUP_PA19          // pin 16\n    //SET_AON_GPIO_WAKEUP_PA21          // pin 18\n//For BW16/BW16-TypeC only the AON GPIO pins listed below should be selected\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 7\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 8\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 9\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 10\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 11\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 12\n//For board AW-CU488_ThingPlus\n    //SET_AON_GPIO_WAKEUP_PA18          // pin 0\n    //SET_AON_GPIO_WAKEUP_PA16          // pin 1\n    //SET_AON_GPIO_WAKEUP_PA17          // pin 2\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 3\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 4\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 5\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 6\n    //SET_AON_GPIO_WAKEUP_PA19          // pin 8\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 28\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 29\n//For board AMB25/AMB26\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 3\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 2\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 1\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 0\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 7\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 6\n//For board SparkFun Thing Plus NORA-W306\n    //SET_AON_GPIO_WAKEUP_PA18          // pin 6\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 13\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 14\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 11\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 12\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 15\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 16\n\n#define DS_WAKEUP_SOURCE                SET_DS_AON_TIMER_WAKEUP\n\n#define AON_TIMER_SLEEP_DURATION        5000\n#define DS_RTC_ALARM_DAY                0\n#define DS_RTC_ALARM_HOUR               0\n#define DS_RTC_ALARM_MIN                0\n#define DS_RTC_ALARM_SEC                10\n\nvoid DeepSleep_wakeup(void) {\n    //printf(\"\\r\\nDeep sleep wakeuped! \\r\\n\");\n    uint32_t wakereason_number = PowerSave.AONWakeReason();\n\n    //pinMode(17, OUTPUT); // 17 SDPC uSD power control\n    //digitalWrite(17, LOW); // Turn on uSD power if you'd like to measure its current consumption   \n\n    if (wakereason_number == AONWakeReason_AON_GPIO) {\n        //printf(\"AonWakepin wakeup. Wait 5s sleep again.    \\r\\n\");\n        delay(5000);\n    } else if (wakereason_number == AONWakeReason_AON_TIMER) {\n        PowerSave.AONTimerCmd();\n        //printf(\"AonTimer wakeup. Wait 5s sleep again.    \\r\\n\");\n\n        pinMode(LED_BUILTIN, OUTPUT);\n        for(int i = 0 ; i &lt; 5 ; i ++)\n        {\n          digitalWrite(LED_BUILTIN, HIGH);\n          delay(1000);\n          digitalWrite(LED_BUILTIN, LOW);\n          delay(1000);\n        }\n        pinMode(LED_BUILTIN, INPUT);\n        //delay(5000);\n    } else if (wakereason_number == AONWakeReason_RTC) {\n        //printf(\"RTC wakeup. Wait 5s sleep again.    \\r\\n\");\n        delay(5000);\n    }\n\n    //pinMode(17, INPUT_PULLUP); // 17 SDPC uSD power control (Pullup = off)\n\n    PowerSave.AONWakeClear();\n}\n\nvoid setup() {\n    // If you want serial debug messages, uncomment the following lines and others\n    // below, as desired.\n    // Open serial communications and wait for port to open:\n    // Serial.begin(115200);\n    // while (!Serial) {\n    //     ; // wait for serial port to connect. Needed for native USB port only\n    // }\n\n    // Pin configuration - specific to the SparkFun Thing Plus NORA-W306\n\n    pinMode(0, INPUT_PULLDOWN); // LOG RX, can backpower the CP2102\n    pinMode(1, INPUT_PULLDOWN); // LOG TX, can backpower the CP2102\n    pinMode(4, INPUT_PULLDOWN); // SPI0_CS, can sink current from 3V3 via R16 (100K), note, this is only possible if you leave uSD power on\n    pinMode(5, INPUT_PULLDOWN); // SPI0_CLK\n    pinMode(6, INPUT_PULLDOWN); // SPI0_PICO\n    pinMode(7, INPUT_PULLDOWN); // SPI0_POCI\n\n    pinMode(11, INPUT_PULLUP); // SDA\n    pinMode(12, INPUT_PULLUP); // SCL\n    pinMode(17, INPUT_PULLUP); // 17 SDPC uSD power control\n    pinMode(20, INPUT_PULLNONE); // aka PB_24, this is tied internally to PB_23 (aka Arduino pin \"17\") and also defaults to internal pulldown.\n\n    PowerSave.begin(DEEPSLEEP_MODE);\n\n    if (TRUE == (PowerSave.DsleepWakeStatusGet())) {\n        DeepSleep_wakeup();\n    }\n\n    PowerSave.AONTimerDuration(0);\n\n    switch (DS_WAKEUP_SOURCE) {\n        case SET_DS_AON_TIMER_WAKEUP:\n            PowerSave.DS_AON_TIMER_WAKEUP();\n            PowerSave.AONTimerDuration(AON_TIMER_SLEEP_DURATION);\n            break;\n        case SET_DS_RTC_WAKEUP:\n            PowerSave.DS_RTC_WAKEUP();\n            PowerSave.RTCWakeSetup(DS_RTC_ALARM_DAY, DS_RTC_ALARM_HOUR, DS_RTC_ALARM_MIN, DS_RTC_ALARM_SEC);\n            break;\n        case SET_AON_GPIO_WAKEUP_PA12:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA12();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA13:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA13();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA14:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA14();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA15:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA15();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA16:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA16();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA17:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA17();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA18:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA18();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA19:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA19();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA20:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA20();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA21:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA21();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA25:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA25();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA26:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA26();\n            break;\n        default:\n            printf(\"Unknown wakeup source.    \\r\\n\");\n        break;\n    }\n\n    PowerSave.enable();\n}\n\nvoid loop() {\n    delay(1000);\n}\n</code></pre> <p>Once connected, choose a power source to connect to the SparkFun Thing Plus NORA-W306. This can be through the PTHs on the edge of the board (VU, VB, or 3V3) or the connectors (USB C, 2-pin JST, or Qwiic). Note that the board will draw more power through the USB C connector and VU PTH as this will power the CP2102. Power will also be drawn with the LiPo charger and 3.3V voltage regulator.</p> <p>Below are a few diagrams showing two possible ways to measure the current draw when the board is in deep sleep mode.</p> Fritzing Diagram of Multimeter Measuring Current through MEAS and a LiPo Battery as the Power Source Fritzing Diagram of Multimeter Measuring Current LiPo Battery and Board <p>If you haven't already, check out the demo video that was linked earlier in the hardware overview showing the current draw for the board in low power mode!</p>"},{"location":"single_page/#example-8-deep-sleep-and-microsd-power-control","title":"Example 8 - Deep Sleep and MicroSD Power Control","text":"<p>In this example, we will read sensor readings from a BME280, log the data to a microSD card, and then go into deep sleep.</p>"},{"location":"single_page/#hardware-hookup_8","title":"Hardware Hookup","text":"<p>To take advantage of the SD power control (SDPC), you will need to make sure to cut the trace on the back of the board and add a solder blob between the center pad and pad labeled as <code>17</code>.</p> MicroSD Card Power Control Jumper Modified <p>When ready, insert a microSD card into the socket on the back of the board. Then connect the Qwiic BME280 to the SparkFun Thing Plus NORA-W306 using a Qwiic cable.</p> Fritzing Diagram BME280 connected to NORA-W306 via Qwiic <p>Connect a USB cable to the board to power and upload code.</p>"},{"location":"single_page/#arduino-code_7","title":"Arduino Code","text":"<p>This example builds upon Realtek's deep sleep like the previous example. In addition to blinking the LED, we will also read the temperature from a BME280 and write the sensor data to the microSD card.</p> <p>Copy and paste the following code in the Arduino IDE. Select your Board (in this case the SparkFun Thing Plus NORA-W306 (RTL8720DF)), and associated COM port (in this case COM23). Then hit the upload button.</p> <pre><code>/*\n* SparkFun Electronics\n* 7/17/2024\n*\n* SparkFun_ThingPlus_NORAW306_DeepSleepTempLogger.ino\n*\n* Deep Sleep mode with data logging  - example for the SparkFun Thing Plus NORA-W306\n*\n* This example demonstrates how to put the NORA-W306 into deep sleep mode and\n* wake it up using the AON timer (every 5 seconds).\n* When awake, it will log the temperature from the BME280 sensor to the uSD card.\n* When awake, it will also blink the stat LED three times to indicate a log has happened.\n* When asleep, the current consumption can be monitored using the MEAS jumper.\n*\n* Hardware Hookup and Instructions:\n*   Connect the NORA-W306 to your computer using a USB-C cable.\n*   Connect the BME280 sensor with a Qwiic Cable.\n*   Upload this code to the NORA-W306.\n*   To measure the low-power consumption of the NORA-W306, remove USB-C cable\n*   and utilize the MEAS jumper to measure the current consumption.\n*   \n* Software versions used in this example:\n*   Arduino IDE 2.3.2\n*   Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz) by Realtek Version 3.1.8\n*     (https://github.com/ambiot/ambd_arduino)\n*     (https://raw.githubusercontent.com/ambiot/ambd_arduino/dev/Arduino_package/package_realtek_amebad_early_index.json)\n*   BME280 library by SparkFun Electronics\n*     (https://github.com/sparkfun/SparkFun_BME280_Arduino_Library)\n*\n* Original code is from the following example in the RealTek Ameba Arduino package:\n*  Examples -&gt; AmebaPowerSave -&gt; DeepSleepMode.ino\n*\n* MIT License\n*\n* Copyright (c) 2024 SparkFun Electronics\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy of\n* this software and associated documentation files (the \"Software\"), to deal in the\n* Software without restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n* Software, and to permit persons to whom the Software is furnished to do so,\n* subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n* PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n// variables to store the readings from the sensor\nfloat humidity;\nfloat pressure;\nfloat altitude;\nfloat temperature;\n\n#include \"SdFat.h\"\n#include \"sdios.h\"\n\nFile myFile;\n\n/*\n  Set DISABLE_CS_PIN to disable a second SPI device.\n  For example, with the Ethernet shield, set DISABLE_CS_PIN\n  to 10 to disable the Ethernet controller.\n*/\nconst int8_t DISABLE_CS_PIN = -1;\n/*\n  Change the value of SD_CS_PIN if you are using SPI\n  and your hardware does not use the default value, SS.\n  Common values are:\n  Arduino Ethernet shield: pin 4\n  Sparkfun SD shield: pin 8\n  Adafruit SD shields and modules: pin 10\n  SparkFun Thing Plus NORA-W306: Arduino pin 4 (aka SS/PB_21/SPI0_CS)\n*/\n// SDCARD_SS_PIN is defined for the built-in SD on some boards.\n#ifndef SDCARD_SS_PIN\nconst uint8_t SD_CS_PIN = SS;\n#else  // SDCARD_SS_PIN\nconst uint8_t SD_CS_PIN = SDCARD_SS_PIN;\n#endif  // SDCARD_SS_PIN\n\n// Try to select the best SD card configuration.\n#if HAS_SDIO_CLASS\n#define SD_CONFIG SdioConfig(FIFO_SDIO)\n#elif ENABLE_DEDICATED_SPI\n#define SD_CONFIG SdSpiConfig(SD_CS_PIN, DEDICATED_SPI, SD_SCK_MHZ(16))\n#else  // HAS_SDIO_CLASS\n#define SD_CONFIG SdSpiConfig(SD_CS_PIN, SHARED_SPI, SD_SCK_MHZ(16))\n#endif  // HAS_SDIO_CLASS\n\n//------------------------------------------------------------------------------\nSdFs sd;\ncid_t cid;\ncsd_t csd;\nscr_t scr;\nuint8_t cmd6Data[64];\nuint32_t eraseSize;\nuint32_t ocr;\nstatic ArduinoOutStream cout(Serial);\n\n\n#include &lt;Wire.h&gt;\n\n#include \"SparkFunBME280.h\"\nBME280 mySensor;\n\n#include &lt;PowerSave.h&gt;\n\n//SET_DS_AON_TIMER_WAKEUP\n//SET_DS_RTC_WAKEUP\n//For AMB21/22 only the AON GPIO pins listed below should be selected\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 16\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 17\n    //SET_AON_GPIO_WAKEUP_PA21          // pin 26\n    //SET_AON_GPIO_WAKEUP_PA20          // pin 27\n    //SET_AON_GPIO_WAKEUP_PA19          // pin 28\n//For AMB23 only the AON GPIO pins listed below should be selected\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 9\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 10\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 11\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 12\n    //SET_AON_GPIO_WAKEUP_PA16          // pin 13\n    //SET_AON_GPIO_WAKEUP_PA18          // pin 15\n    //SET_AON_GPIO_WAKEUP_PA19          // pin 16\n    //SET_AON_GPIO_WAKEUP_PA21          // pin 18\n//For BW16/BW16-TypeC only the AON GPIO pins listed below should be selected\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 7\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 8\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 9\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 10\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 11\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 12\n//For board AW-CU488_ThingPlus\n    //SET_AON_GPIO_WAKEUP_PA18          // pin 0\n    //SET_AON_GPIO_WAKEUP_PA16          // pin 1\n    //SET_AON_GPIO_WAKEUP_PA17          // pin 2\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 3\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 4\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 5\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 6\n    //SET_AON_GPIO_WAKEUP_PA19          // pin 8\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 28\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 29\n//For board AMB25/AMB26\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 3\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 2\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 1\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 0\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 7\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 6\n//For board SparkFun Thing Plus NORA-W306\n    //SET_AON_GPIO_WAKEUP_PA18          // pin 6\n    //SET_AON_GPIO_WAKEUP_PA13          // pin 13\n    //SET_AON_GPIO_WAKEUP_PA12          // pin 14\n    //SET_AON_GPIO_WAKEUP_PA26          // pin 11\n    //SET_AON_GPIO_WAKEUP_PA25          // pin 12\n    //SET_AON_GPIO_WAKEUP_PA15          // pin 15\n    //SET_AON_GPIO_WAKEUP_PA14          // pin 16\n\n#define DS_WAKEUP_SOURCE                SET_DS_AON_TIMER_WAKEUP\n\n#define AON_TIMER_SLEEP_DURATION        5000\n#define DS_RTC_ALARM_DAY                0\n#define DS_RTC_ALARM_HOUR               0\n#define DS_RTC_ALARM_MIN                0\n#define DS_RTC_ALARM_SEC                10\n\nvoid DeepSleep_wakeup(void) {\n    //printf(\"\\r\\nDeep sleep wakeuped! \\r\\n\");\n    uint32_t wakereason_number = PowerSave.AONWakeReason();\n\n    readSensor();\n\n    if (wakereason_number == AONWakeReason_AON_GPIO) {\n        //printf(\"AonWakepin wakeup. Wait 5s sleep again.    \\r\\n\");\n        delay(5000);\n    } else if (wakereason_number == AONWakeReason_AON_TIMER) {\n        PowerSave.AONTimerCmd();\n        //printf(\"AonTimer wakeup. Wait 5s sleep again.    \\r\\n\");\n\n        pinMode(LED_BUILTIN, OUTPUT);\n        for(int i = 0 ; i &lt; 3 ; i ++)\n        {\n          digitalWrite(LED_BUILTIN, HIGH);\n          delay(100);\n          digitalWrite(LED_BUILTIN, LOW);\n          delay(100);\n        }\n        pinMode(LED_BUILTIN, INPUT);\n        //delay(5000);\n    } else if (wakereason_number == AONWakeReason_RTC) {\n\n        printf(\"RTC wakeup. Wait 5s sleep again.    \\r\\n\");\n\n        delay(5000);\n    }\n\n    pinMode(0, INPUT_PULLDOWN); // LOG RX, can backpower the CP2102\n    pinMode(1, INPUT_PULLDOWN); // LOG TX, can backpower the CP2102\n    pinMode(4, INPUT_PULLDOWN); // SPI0_CS, can sink current from 3V3 via R16 (100K), note, this is only possible if you leave uSD power on\n    pinMode(5, INPUT_PULLDOWN); // SPI0_CLK\n    pinMode(6, INPUT_PULLDOWN); // SPI0_PICO\n    pinMode(7, INPUT_PULLDOWN); // SPI0_POCI\n    pinMode(11, INPUT_PULLUP); // SDA\n    pinMode(12, INPUT_PULLUP); // SCL\n    pinMode(17, INPUT_PULLUP); // 17 SDPC uSD power control\n    pinMode(20, INPUT_PULLNONE); // aka PB_24, this is tied internally to PB_23 (aka Arduino pin \"17\") and also defaults to internal pulldown.\n\n    PowerSave.AONWakeClear();\n}\n\nvoid setup() {\n    // If you want serial debug messages, uncomment the following lines and others\n    // below, as desired.\n    // Open serial communications and wait for port to open:\n    // Serial.begin(115200);\n    // while (!Serial) {\n    //     ; // wait for serial port to connect. Needed for native USB port only\n    // }\n\n    PowerSave.begin(DEEPSLEEP_MODE);\n\n    if (TRUE == (PowerSave.DsleepWakeStatusGet())) {\n        DeepSleep_wakeup();\n    }\n\n    PowerSave.AONTimerDuration(0);\n\n    switch (DS_WAKEUP_SOURCE) {\n        case SET_DS_AON_TIMER_WAKEUP:\n            PowerSave.DS_AON_TIMER_WAKEUP();\n            PowerSave.AONTimerDuration(AON_TIMER_SLEEP_DURATION);\n            break;\n        case SET_DS_RTC_WAKEUP:\n            PowerSave.DS_RTC_WAKEUP();\n            PowerSave.RTCWakeSetup(DS_RTC_ALARM_DAY, DS_RTC_ALARM_HOUR, DS_RTC_ALARM_MIN, DS_RTC_ALARM_SEC);\n            break;\n        case SET_AON_GPIO_WAKEUP_PA12:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA12();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA13:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA13();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA14:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA14();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA15:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA15();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA16:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA16();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA17:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA17();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA18:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA18();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA19:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA19();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA20:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA20();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA21:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA21();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA25:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA25();\n            break;\n        case SET_AON_GPIO_WAKEUP_PA26:\n            PowerSave.AON_WAKEPIN_WAKEUP_PA26();\n            break;\n        default:\n            printf(\"Unknown wakeup source.    \\r\\n\");\n        break;\n    }\n\n    PowerSave.enable();\n}\n\nvoid loop() {\n    delay(1000);\n}\n\nvoid readSensor()\n{\n    pinMode(0, INPUT); // LOG RX, can backpower the CP2102\n    pinMode(1, OUTPUT); // LOG TX, can backpower the CP2102\n\n    pinMode(11, OUTPUT); // SDA\n    pinMode(12, OUTPUT); // SCL\n\n    pinMode(17, OUTPUT); // 17 SDPC uSD power control\n    digitalWrite(17, LOW); // uSD power GND = ON\n\n    Serial.begin(115200);\n\n    cout &lt;&lt; F(\"SdFat version: \") &lt;&lt; SD_FAT_VERSION_STR &lt;&lt; endl;\n    printConfig(SD_CONFIG);\nuint32_t t = millis();\n      if (!sd.cardBegin(SD_CONFIG)) {\n    cout &lt;&lt; F(\n           \"\\nSD initialization failed.\\n\"\n           \"Do not reformat the card!\\n\"\n           \"Is the card correctly inserted?\\n\"\n           \"Is there a wiring/soldering problem?\\n\");\n    if (isSpi(SD_CONFIG)) {\n      cout &lt;&lt; F(\n           \"Is SD_CS_PIN set to the correct value?\\n\"\n           \"Does another SPI device need to be disabled?\\n\"\n           );\n    }\n    errorPrint();\n    return;\n  }\n\n    t = millis() - t;\n  cout &lt;&lt; F(\"init time: \") &lt;&lt; dec &lt;&lt; t &lt;&lt; \" ms\" &lt;&lt; endl;\n\n  if (!sd.card()-&gt;readCID(&amp;cid) ||\n      !sd.card()-&gt;readCSD(&amp;csd) ||\n      !sd.card()-&gt;readOCR(&amp;ocr) ||\n      !sd.card()-&gt;readSCR(&amp;scr)) {\n    cout &lt;&lt; F(\"readInfo failed\\n\");\n    errorPrint();\n    return;\n  }\n  printCardType();\n  cout &lt;&lt; F(\"sdSpecVer: \") &lt;&lt; 0.01*scr.sdSpecVer() &lt;&lt; endl;\n  cout &lt;&lt; F(\"HighSpeedMode: \");\n  if (scr.sdSpecVer() &amp;&amp;\n    sd.card()-&gt;cardCMD6(0X00FFFFFF, cmd6Data) &amp;&amp; (2 &amp; cmd6Data[13])) {\n    cout &lt;&lt; F(\"true\\n\");\n  } else {\n    cout &lt;&lt; F(\"false\\n\");\n  }      \n  cidDmp();\n  csdDmp();\n  cout &lt;&lt; F(\"\\nOCR: \") &lt;&lt; uppercase &lt;&lt; showbase;\n  cout &lt;&lt; hex &lt;&lt; ocr &lt;&lt; dec &lt;&lt; endl;\n  if (!mbrDmp()) {\n    return;\n  }\n  if (!sd.volumeBegin()) {\n    cout &lt;&lt; F(\"\\nvolumeBegin failed. Is the card formatted?\\n\");\n    errorPrint();\n    return;\n  }\n  dmpVol();\n\n\n\n\n    Wire.begin();\n    Wire.setClock(400000); //Increase to fast I2C speed!\n    if (mySensor.beginI2C() == false) //Begin communication over I2C\n    {\n        printf(\"The sensor did not respond. Please check wiring.\");\n        while(1); //Freeze\n    }\n\n    mySensor.setMode(MODE_FORCED); //Wake up sensor and take reading\n\n    while(mySensor.isMeasuring() == false) ; //Wait for sensor to start measurment\n    while(mySensor.isMeasuring() == true) ; //Hang out while sensor completes the reading    \n\n    humidity = mySensor.readFloatHumidity();\n    pressure = mySensor.readFloatPressure();\n    altitude = mySensor.readFloatAltitudeFeet();\n    temperature = mySensor.readTempF();\n\n    printf(\" Humidity: \");\n    printf(\"%d\", int(humidity));\n\n    printf(\" Pressure: \");\n    printf(\"%d\", int(pressure));\n\n    printf(\" Altitude: \");\n    printf(\"%d\", int(altitude));\n\n    printf(\" Temperature: \");\n    printf(\"%d\", int(temperature));\n\n    mySensor.setMode(MODE_SLEEP); //Sleep for now\n\n    Wire.end();\n\n    logDataToSd();\n}\n\n//------------------------------------------------------------------------------\nvoid cidDmp() {\n  cout &lt;&lt; F(\"\\nManufacturer ID: \");\n  cout &lt;&lt; uppercase &lt;&lt; showbase &lt;&lt; hex &lt;&lt; int(cid.mid) &lt;&lt; dec &lt;&lt; endl;\n  cout &lt;&lt; F(\"OEM ID: \") &lt;&lt; cid.oid[0] &lt;&lt; cid.oid[1] &lt;&lt; endl;\n  cout &lt;&lt; F(\"Product: \");\n  for (uint8_t i = 0; i &lt; 5; i++) {\n    cout &lt;&lt; cid.pnm[i];\n  }\n  cout &lt;&lt; F(\"\\nRevision: \") &lt;&lt; cid.prvN() &lt;&lt; '.' &lt;&lt; cid.prvM() &lt;&lt; endl;\n  cout &lt;&lt; F(\"Serial number: \") &lt;&lt; hex &lt;&lt; cid.psn() &lt;&lt; dec &lt;&lt; endl;\n  cout &lt;&lt; F(\"Manufacturing date: \");\n  cout &lt;&lt; cid.mdtMonth() &lt;&lt; '/' &lt;&lt; cid.mdtYear() &lt;&lt; endl;\n  cout &lt;&lt; endl;\n}\n//------------------------------------------------------------------------------\nvoid clearSerialInput() {\n  uint32_t m = micros();\n  do {\n    if (Serial.read() &gt;= 0) {\n      m = micros();\n    }\n  } while (micros() - m &lt; 10000);\n}\n//------------------------------------------------------------------------------\nvoid csdDmp() {\n  eraseSize = csd.eraseSize();\n  cout &lt;&lt; F(\"cardSize: \") &lt;&lt; 0.000512 * csd.capacity();\n  cout &lt;&lt; F(\" MB (MB = 1,000,000 bytes)\\n\");\n\n\n  cout &lt;&lt; F(\"flashEraseSize: \") &lt;&lt; int(eraseSize) &lt;&lt; F(\" blocks\\n\");\n  cout &lt;&lt; F(\"eraseSingleBlock: \");\n  if (csd.eraseSingleBlock()) {\n    cout &lt;&lt; F(\"true\\n\");\n  } else {\n    cout &lt;&lt; F(\"false\\n\");\n  }\n  cout &lt;&lt; F(\"dataAfterErase: \");\n  if (scr.dataAfterErase()) {\n    cout &lt;&lt; F(\"ones\\n\");\n  } else {\n    cout &lt;&lt; F(\"zeros\\n\");\n  }\n}\n//------------------------------------------------------------------------------\nvoid errorPrint() {\n  if (sd.sdErrorCode()) {\n    cout &lt;&lt; F(\"SD errorCode: \") &lt;&lt; hex &lt;&lt; showbase;\n    printSdErrorSymbol(&amp;Serial, sd.sdErrorCode());\n    cout &lt;&lt; F(\" = \") &lt;&lt; int(sd.sdErrorCode()) &lt;&lt; endl;\n    cout &lt;&lt; F(\"SD errorData = \") &lt;&lt; int(sd.sdErrorData()) &lt;&lt; dec &lt;&lt; endl;\n  }\n}\n//------------------------------------------------------------------------------\nbool mbrDmp() {\n  MbrSector_t mbr;\n  bool valid = true;\n  if (!sd.card()-&gt;readSector(0, (uint8_t*)&amp;mbr)) {\n    cout &lt;&lt; F(\"\\nread MBR failed.\\n\");\n    errorPrint();\n    return false;\n  }\n  cout &lt;&lt; F(\"\\nSD Partition Table\\n\");\n  cout &lt;&lt; F(\"part,boot,bgnCHS[3],type,endCHS[3],start,length\\n\");\n  for (uint8_t ip = 1; ip &lt; 5; ip++) {\n    MbrPart_t *pt = &amp;mbr.part[ip - 1];\n    if ((pt-&gt;boot != 0 &amp;&amp; pt-&gt;boot != 0X80) ||\n        getLe32(pt-&gt;relativeSectors) &gt; csd.capacity()) {\n      valid = false;\n    }\n    cout &lt;&lt; int(ip) &lt;&lt; ',' &lt;&lt; uppercase &lt;&lt; showbase &lt;&lt; hex;\n    cout &lt;&lt; int(pt-&gt;boot) &lt;&lt; ',';\n    for (int i = 0; i &lt; 3; i++ ) {\n      cout &lt;&lt; int(pt-&gt;beginCHS[i]) &lt;&lt; ',';\n    }\n    cout &lt;&lt; int(pt-&gt;type) &lt;&lt; ',';\n    for (int i = 0; i &lt; 3; i++ ) {\n      cout &lt;&lt; int(pt-&gt;endCHS[i]) &lt;&lt; ',';\n    }\n    cout &lt;&lt; dec &lt;&lt; getLe32(pt-&gt;relativeSectors) &lt;&lt; ',';\n    cout &lt;&lt; getLe32(pt-&gt;totalSectors) &lt;&lt; endl;\n  }\n  if (!valid) {\n    cout &lt;&lt; F(\"\\nMBR not valid, assuming Super Floppy format.\\n\");\n  }\n  return true;\n}\n//------------------------------------------------------------------------------\nvoid dmpVol() {\n  cout &lt;&lt; F(\"\\nScanning FAT, please wait.\\n\");\n  int32_t freeClusterCount = sd.freeClusterCount();\n  if (sd.fatType() &lt;= 32) {\n    cout &lt;&lt; F(\"\\nVolume is FAT\") &lt;&lt; int(sd.fatType()) &lt;&lt; endl;\n  } else {\n    cout &lt;&lt; F(\"\\nVolume is exFAT\\n\");\n  }\n  cout &lt;&lt; F(\"sectorsPerCluster: \") &lt;&lt; sd.sectorsPerCluster() &lt;&lt; endl;\n  cout &lt;&lt; F(\"fatStartSector:    \") &lt;&lt; sd.fatStartSector() &lt;&lt; endl;\n  cout &lt;&lt; F(\"dataStartSector:   \") &lt;&lt; sd.dataStartSector() &lt;&lt; endl;\n  cout &lt;&lt; F(\"clusterCount:      \") &lt;&lt; sd.clusterCount() &lt;&lt; endl;  \n  cout &lt;&lt; F(\"freeClusterCount:  \");\n  if (freeClusterCount &gt;= 0) {\n    cout &lt;&lt; freeClusterCount &lt;&lt; endl;\n  } else {\n    cout &lt;&lt; F(\"failed\\n\");\n    errorPrint();    \n  }\n}\n//------------------------------------------------------------------------------\nvoid printCardType() {\n  cout &lt;&lt; F(\"\\nCard type: \");\n  switch (sd.card()-&gt;type()) {\n    case SD_CARD_TYPE_SD1:\n      cout &lt;&lt; F(\"SD1\\n\");\n      break;\n    case SD_CARD_TYPE_SD2:\n      cout &lt;&lt; F(\"SD2\\n\");\n      break;\n    case SD_CARD_TYPE_SDHC:\n      if (csd.capacity() &lt; 70000000) {\n        cout &lt;&lt; F(\"SDHC\\n\");\n      } else {\n        cout &lt;&lt; F(\"SDXC\\n\");\n      }\n      break;\n    default:\n      cout &lt;&lt; F(\"Unknown\\n\");\n  }\n}\n//------------------------------------------------------------------------------\nvoid printConfig(SdSpiConfig config) {\n  if (DISABLE_CS_PIN &lt; 0) {\n    cout &lt;&lt; F(\n           \"\\nAssuming the SD is the only SPI device.\\n\"\n           \"Edit DISABLE_CS_PIN to disable an SPI device.\\n\");\n  } else {\n    cout &lt;&lt; F(\"\\nDisabling SPI device on pin \");\n    cout &lt;&lt; int(DISABLE_CS_PIN) &lt;&lt; endl;\n    pinMode(DISABLE_CS_PIN, OUTPUT);\n    digitalWrite(DISABLE_CS_PIN, HIGH);\n  }\n  cout &lt;&lt; F(\"\\nAssuming the SD chip select pin is: \") &lt;&lt; int(config.csPin);\n  cout &lt;&lt; F(\"\\nEdit SD_CS_PIN to change the SD chip select pin.\\n\");\n}\n//------------------------------------------------------------------------------\nvoid printConfig(SdioConfig config) {\n  (void)config;\n  cout &lt;&lt; F(\"Assuming an SDIO interface.\\n\");\n}\n\n//------------------------------------------------------------------------------\nvoid logDataToSd()\n{\n  // open the file. note that only one file can be open at a time,\n  // so you have to close this one before opening another.\n  myFile = sd.open(\"log.txt\", FILE_WRITE);\n\n  // if the file opened okay, write to it:\n  if (myFile) {\n    Serial.print(\"Writing to log.txt...\");\n\n    myFile.print(\"Humidity:\");\n    myFile.print(humidity);\n    myFile.print(\",Pressure:\");\n    myFile.print(pressure);\n    myFile.print(\",Altitude:\");\n    myFile.print(altitude);\n    myFile.print(\",Temperature:\");\n    myFile.println(temperature);\n\n    // close the file:\n    myFile.close();\n    Serial.println(\"done.\");\n  } else {\n    // if the file didn't open, print an error:\n    Serial.println(\"error opening log.txt\");\n  }\n\n  // re-open the file for reading:\n  myFile = sd.open(\"log.txt\");\n  if (myFile) {\n    Serial.println(\"log.txt:\");\n\n\n    // read from the file until there's nothing else in it:\n    while (myFile.available()) {\n      Serial.write(myFile.read());\n    }\n    // close the file:\n    myFile.close();\n  } else {\n    // if the file didn't open, print an error:\n    Serial.println(\"error opening log.txt\");\n  }\n}\n</code></pre> <p>Open the Arduino Serial Monitor at 115200 to view the output. You should see the NORA-W306 wake up, read the sensor data, user LED blink, print the data as an integer through the serial terminal, write to a file, and then close the file. For verification, the code will also re-open the file, print the contents of the file, and then close the file again. This is a good time to verify if the sensor readings are being written at the end of the file.</p> Arduino Output from the NORA-W306's Deep Sleep and Datalogging Example <p>Tip</p> <p>For users that need to comment out the lines of code to re-open the file and read the sensor data, you will just need to add a multiline comment (i.e. /* and <code>*/</code>) around the following lines of code as shown below.</p> <pre><code>  // re-open the file for reading:\n  /*myFile = sd.open(\"log.txt\");\n  if (myFile) {\n    Serial.println(\"log.txt:\");\n\n\n    // read from the file until there's nothing else in it:\n    while (myFile.available()) {\n      Serial.write(myFile.read());\n    }\n    // close the file:\n    myFile.close();\n  } else {\n    // if the file didn't open, print an error:\n    Serial.println(\"error opening log.txt\");\n  }*/\n</code></pre> <p>Note</p> <p>The sensor output in the Arduino Serial Monitor displayed the sensor reading as integers. When writing to the file, the sensor readings were floats.</p> <p>For those that want to verify through a text editor, remove the USB cable from the NORA-W306. Then remove the microSD card from the board. Connect the microSD card to your computer. Using a text editor, open the file labeled as log.txt. You should see the sensor readings that were logged earlier. You may have an additional line of comma separated values written to the file before removing power from the board.</p> Log File Opened Through Text Editor Displaying Sensor Readings <p>For those interested in viewing the current consumption, cut the MEAS jumper on the back of the NORA-W306. Solder a 1x2 breakaway male header to the board. Then connect it to a multimeter to measure the current consumption. Using a LiPo battery will bring down the current consumption since the LiPo battery charger, CHG LED, and CP2102 USB-to-serial converter are not being powered. Try disabling the power LED jumpers on the NORA-W306 and BME280. You can take it a step further by also disabling power to the WS2812 by cutting the JP3 jumper.</p> Fritzing Diagrams with Multimeter Connected to NORA-W306's MEAS Jumper"},{"location":"single_page/#example-9-max17048-lipo-fuel-gauge","title":"Example 9 - MAX17048 LiPo Fuel Gauge","text":"<p>In this example, we will measure the LiPo battery's capacity using the built-in MAX17048 LiPo Fuel Gauge.</p>"},{"location":"single_page/#hardware-hookup_9","title":"Hardware Hookup","text":"<p>We recommend connecting a single cell LiPo battery to the 2-pin JST style connector. If you have not already, connect a compatible single cell, LiPo battery to the board.</p> Battery Connected <p>When ready, connect the board to your computer with the USB C cable.</p>"},{"location":"single_page/#installing-the-arduino-library_1","title":"Installing the Arduino Library","text":"<p>First, you'll need to download and install the SparkFun MAX1704x Fuel Gauge Arduino Library. You can install this library automatically in the Arduino IDE's Library Manager by searching for \"SparkFun MAX1704x Fuel Gauge\". Or you can manually download it from the GitHub repository.</p> Download the SparkFun MAX1704x Fuel Gauge Arduino Library (ZIP)"},{"location":"single_page/#arduino-code_8","title":"Arduino Code","text":"<p>In this example, we will be checking a single cell LiPo battery's voltage and the state of charge using the MAX17048. The output will be sent to the Serial Monitor.</p> <p>From the menu, select the following: File &gt; Examples &gt; SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library &gt; Example1_Simple. Comment out the default instance for the MAX17043 and uncomment the line for the MAX17048.</p> <pre><code>//SFE_MAX1704X lipo; // Defaults to the MAX17043\n\n//SFE_MAX1704X lipo(MAX1704X_MAX17043); // Create a MAX17043\n//SFE_MAX1704X lipo(MAX1704X_MAX17044); // Create a MAX17044\nSFE_MAX1704X lipo(MAX1704X_MAX17048); // Create a MAX17048\n//SFE_MAX1704X lipo(MAX1704X_MAX17049); // Create a MAX17049\n</code></pre> <p>Or you can copy and paste the following code in the Arduino IDE. Select your Board (in this case the SparkFun Thing Plus NORA-W306 (RTL8720DF)), and associated COM port (in this case COM13). Then hit the upload button.</p> <pre><code>/******************************************************************************\nExample1_Simple\nBy: Paul Clark\nDate: October 23rd 2020\n\nBased extensively on:\nMAX17043_Simple_Serial.cpp\nSparkFun MAX17043 Example Code\nJim Lindblom @ SparkFun Electronics\nOriginal Creation Date: June 22, 2015\n\nThis file demonstrates the simple API of the SparkFun MAX17043 Arduino library.\n\nThis example will print the gauge's voltage and state-of-charge (SOC) readings\nto Serial (115200 baud)\n\nThis code is released under the MIT license.\n\nDistributed as-is; no warranty is given.\n******************************************************************************/\n\n#include &lt;Wire.h&gt; // Needed for I2C\n\n#include &lt;SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library.h&gt; // Click here to get the library: http://librarymanager/All#SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library\n\n//SFE_MAX1704X lipo; // Defaults to the MAX17043\n\n//SFE_MAX1704X lipo(MAX1704X_MAX17043); // Create a MAX17043\n//SFE_MAX1704X lipo(MAX1704X_MAX17044); // Create a MAX17044\nSFE_MAX1704X lipo(MAX1704X_MAX17048); // Create a MAX17048\n//SFE_MAX1704X lipo(MAX1704X_MAX17049); // Create a MAX17049\n\ndouble voltage = 0; // Variable to keep track of LiPo voltage\ndouble soc = 0; // Variable to keep track of LiPo state-of-charge (SOC)\nbool alert; // Variable to keep track of whether alert has been triggered\n\nvoid setup()\n{\n    Serial.begin(115200); // Start serial, to output debug data\n  while (!Serial)\n    ; //Wait for user to open terminal\n  Serial.println(F(\"MAX17043 Example\"));\n\n  Wire.begin();\n\n  lipo.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial\n\n  // Set up the MAX17043 LiPo fuel gauge:\n  if (lipo.begin() == false) // Connect to the MAX17043 using the default wire port\n  {\n    Serial.println(F(\"MAX17043 not detected. Please check wiring. Freezing.\"));\n    while (1)\n      ;\n  }\n\n    // Quick start restarts the MAX17043 in hopes of getting a more accurate\n    // guess for the SOC.\n    lipo.quickStart();\n\n    // We can set an interrupt to alert when the battery SoC gets too low.\n    // We can alert at anywhere between 1% - 32%:\n    lipo.setThreshold(20); // Set alert threshold to 20%.\n}\n\nvoid loop()\n{\n  // lipo.getVoltage() returns a voltage value (e.g. 3.93)\n  voltage = lipo.getVoltage();\n  // lipo.getSOC() returns the estimated state of charge (e.g. 79%)\n  soc = lipo.getSOC();\n  // lipo.getAlert() returns a 0 or 1 (0=alert not triggered)\n  alert = lipo.getAlert();\n\n  // Print the variables:\n  Serial.print(\"Voltage: \");\n  Serial.print(voltage);  // Print the battery voltage\n  Serial.println(\" V\");\n\n  Serial.print(\"Percentage: \");\n  Serial.print(soc); // Print the battery state of charge\n  Serial.println(\" %\");\n\n  Serial.print(\"Alert: \");\n  Serial.println(alert);\n  Serial.println();\n\n  delay(500);\n}\n</code></pre> <p>Open the Arduino Serial Monitor and set it to 115200 baud to view the serial output. You should see the voltage, battery percent, alert flag, and several more readings. In this case, the single cell LiPo battery that was connected to the IC was fully charged and at about 4.10V.</p> Arduino Output Showing the LiPo Battery's Capacity <p>But wait! If you looked closely at the circuit of the SparkFun Thing Plus NORA-W306, there is also a charge circuit built in. Try closing out the Arduino Serial Monitor, disconnecting the USB, and disconnecting the LiPo battery. Then reinsert the LiPo battery, connect the USB cable, and reopen the Arduino Serial Monitor. The IC will recalculate everything. In the image below, the voltage is a bit misleading since the charge IC is charging the LiPo battery and may not be the true representation of the LiPo battery's voltage. The remaining charge was closer to what was expected.</p> Arduino Output Showing the LiPo Battery's Capacity <p>Note</p> <p>For development boards that have a built in charge circuit and fuel gauge, you may want to consider using a display to view the LiPo battery's true voltage and remaining charge. Otherwise, you could use a multimeter to measure the LiPo battery's voltage when a USB cable is not plugged in. Below is an example that uses the Qwiic Micro OLED to display the LiPo battery's voltage and remaining charge since the SparkFun Thing Plus NORA-W306 includes a built in charge circuit and fuel gauge (MAX17048). Just make sure to adjust the code for your fuel gauge and display.</p> <p> LiPo Fuel Gauge Monitoring LiPo Battery and Displaying Battery Capacity on Qwiic Micro OLED </p>"},{"location":"single_page/#example-10-ws2812-addressable-rgb-led","title":"Example 10 - WS2812 Addressable RGB LED","text":"<p>In this example, we will blink the WS2812.</p>"},{"location":"single_page/#hardware-hookup_10","title":"Hardware Hookup","text":"<p>The connection is the same as explained earlier in the tutorial. Connect the USB cable to the SparkFun Thing Plus NORA-W306 and the other end to your computer. For the scope of this tutorial, we will be using the built-in WS2812B on the development board.</p> <p>For those that are interested in connecting additional WS2812, you can follow the table below to daisy chain additional LEDs. This configuration is when users are using USB for power and daisy chaining a small number of WS2812's.</p> NORA-W306Pinout              WS2812 LEDPinout              VUSB (if powering off USBand low number of WS2812 LEDs) VIN LD/LED_D0 DI GND GND <p>For large number of LEDs, you may want to considering using an external power supply to power the strip of addressable LEDs.</p> NORA-W306Pinout              External 5V Power Supply              WS2812 LEDPinout              5V VIN LD/LED_D0 DI GND GND GND"},{"location":"single_page/#arduino-code_9","title":"Arduino Code","text":"<p>Let's upload the sketch control the WS2812. We recommend using the WS2812B Arduino Library that came installed with the board add-on. Below is a modified example of the WS2812B_Basics.ino sketch since we the LED is on the secondary SPI port and we are using new terminology for the macro. Of course, since we are using only one WS2812, we also adjusted the code to acknowledge that we have only controlling one LED. Copy and paste the following code in the Arduino IDE.</p> <p>Note</p> <p>This code is modified and not the same as the one in the board-add on!!! A few lines were commented out, a macro was used when making an instance of the WS2812B, one LED is used, and the red and green colors are blinking in the loop. For a comparison, you could view the original code provided in the board support package by heading to: File &gt; Examples &gt; File &gt; Examples &gt; Examples for SparkFun Thing Plus NORA-W306 (RTL8720DF) | AmebaWS2812B &gt; WS2812B_Basics.</p> <p>Copy and paste the following code in the Arduino IDE. Select the correct board definition from the menu (in this case, Tools &gt; Board &gt; Realtek Ameba Boards (32-bits ARM Cortex-M33 @200MHz) &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF)). Then select the correct COM port that the board enumerated to (in this case, it was COM13). Hit upload button.  </p> <pre><code>/*\n\n Example guide:\n https://www.amebaiot.com/en/amebad-arduino-ws2812b-basics/\n */\n\n#include \"WS2812B.h\"\n\n#define TOTAL_NUM_OF_LED 1\n#define NUM_OF_LEDS 1\n\n// There are multiple choice of SPI_MOSI pins depends on different boards. The default is SPI_MOSI/SPI1_MOSI\n// AMB21/AMB22              pin 11 /  pin21\n// AMB23                    pin 9  /  pin 4\n// BW16/BW16 Type C         pin 12\n// AW-CU488 ThingPlus       pin 1  /  pin 14\n// AMB25/AMB26              pin 17 /  pin 3\n// NORA-W306 Thing Plus     pin 6  /  pin 14\n\n\n//WS2812B led(SPI_MOSI, TOTAL_NUM_OF_LED);  //default SPI macro\nWS2812B led(SPI1_PICO, TOTAL_NUM_OF_LED); // SPI1 macro for NORA-W306 since built-in WS2812 is attached to secondary SPI pin\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(\"WS2812B test\");\n    led.begin();\n    //Set a specific LED with a certain color\n    led.setPixelColor(0, 50, 0, 0);\n    //led.setPixelColor(1, 0, 50, 0);\n    //led.setPixelColor(2, 0, 0, 50);\n    led.show();\n    delay(1000);\n    //Fill the entire LED strip with the same color\n    //led.fill(60, 0, 25, 0, NUM_OF_LEDS);\n    //led.show();\n}\n\nvoid loop() {\n    led.setPixelColor(0, 50, 0, 0);\n    led.show();\n    delay(1000);\n\n    led.setPixelColor(0, 0, 50, 0);\n    led.show();\n    delay(1000);\n}\n</code></pre> <p>After uploading code, the built-in WS2812B LED will light up red momentarily. Once in the loop, the red and green LED will blink back and forth every second. Try adjusting the code to control the LED to make primary, secondary, or tertiary colors with the press of a button! Or changing the color of the LED based on how much power your LiPo battery has available. Or even modify the WS2812B_Patterns.ino included with the board add-on to add effects and patterns to your LED. You can even go as far as soldering additional WS2812Bs by daisy chaining them to the DO / LED_DO pin. Just make sure that you have a sufficient power supply to power your all of your LEDs.</p> WS2812 Addressable LED Green LED Turned On"},{"location":"single_page/#example-11-qwiic-micro-oled","title":"Example 11 - Qwiic Micro OLED","text":"<p>In this example, we will connect a Qwiic-enabled Micro OLED display.</p>"},{"location":"single_page/#hardware-hookup_11","title":"Hardware Hookup","text":"<p>To connect the Qwiic Micro OLED, simply insert a Qwiic cable between the display and the SparkFun Thing Plus NORA-W306.</p> Qwiic Micro OLED Connected to SparkFun Thing Plus NORA-W306 <p>When ready, connect the board to your computer with the USB C cable.</p>"},{"location":"single_page/#installing-the-arduino-library_2","title":"Installing the Arduino Library","text":"<p>Note</p> <p>There are two SparkFun Arduino Libraries for the Qwiic micro OLED. We recommend using the SparkFun Qwiic OLED Arduino Library.</p> <p>If you have not already, make sure to install the following libraries as explained earlier.</p> <ul> <li>Qwiic OLED</li> </ul>"},{"location":"single_page/#arduino-code_10","title":"Arduino Code","text":"<p>Let's upload the sketch to display graphics and characters on the Qwiic Micro OLED. From the menu, select the following: File &gt; Examples &gt; Examples from Custom Libraries | SparkFun OLED Graphics Library &gt; Example-01_Hello.</p> <p>Or you can copy and paste the following code in the Arduino IDE. Select the correct board definition from the menu (in this case, Tools &gt; Boards &gt; SparkFun Thing Plus NORA-W306 (RTL8720DF)). Then select the correct COM port that the board enumerated to (in this case, it was COM13). Hit upload button.</p> <pre><code>/*\n\n  Example-01_Hello.ino\n\n  This demo shows the basic setup of the OLED library, generating simple graphics and displaying\n  the results on the target device.\n\n   Micro OLED             https://www.sparkfun.com/products/14532\n   Transparent OLED       https://www.sparkfun.com/products/15173\n   \"Narrow\" OLED          https://www.sparkfun.com/products/24606\n   Qwiic OLED 1.3in       https://www.sparkfun.com/products/23453\n\n  Written by Kirk Benell @ SparkFun Electronics, March 2022\n\n  Repository:\n     https://github.com/sparkfun/SparkFun_Qwiic_OLED_Arduino_Library\n\n  Documentation:\n     https://sparkfun.github.io/SparkFun_Qwiic_OLED_Arduino_Library/\n\n  SparkFun code, firmware, and software is released under the MIT License(http://opensource.org/licenses/MIT).\n*/\n\n#include &lt;SparkFun_Qwiic_OLED.h&gt; //http://librarymanager/All#SparkFun_Qwiic_OLED\n\n// The Library supports four different types of SparkFun boards. The demo uses the following\n// defines to determine which device is being used. Uncomment the device being used for this demo.\n\nQwiicMicroOLED myOLED;\n//QwiicTransparentOLED myOLED;\n//QwiicNarrowOLED myOLED;\n//Qwiic1in3OLED myOLED;\n\n\nvoid setup()\n{\n    Serial.begin(115200);\n    Serial.println(\"Running OLED example\");\n\n    Wire.begin();\n\n    // Initalize the OLED device and related graphics system\n    if (myOLED.begin() == false)\n    {\n        Serial.println(\"Device begin failed. Freezing...\");\n        while (true)\n            ;\n    }\n    Serial.println(\"Begin success\");\n\n    // Do a simple test - fill a rectangle on the screen and then print hello!\n\n    // Fill a rectangle on the screen that has a 4 pixel board\n    myOLED.rectangleFill(4, 4, myOLED.getWidth() - 8, myOLED.getHeight() - 8);\n\n    String hello = \"hello\"; // our message\n\n    // Center our message on the screen. Get the screen size of the \"hello\" string,\n    // calling the getStringWidth() and getStringHeight() methods on the oled\n\n    // starting x position - screen width minus string width  / 2\n    int x0 = (myOLED.getWidth() - myOLED.getStringWidth(hello)) / 2;\n\n    // starting y position - screen height minus string height / 2\n    int y0 = (myOLED.getHeight() - myOLED.getStringHeight(hello)) / 2;\n\n    // Draw the text - color of black (0)\n    myOLED.text(x0, y0, hello, 0);\n\n    // There's nothing on the screen yet - Now send the graphics to the device\n    myOLED.display();\n\n    // That's it - HELLO!\n}\n\nvoid loop()\n{\n    delay(1000); // Do nothing\n}\n</code></pre> <p>Once the code has been uploaded, check the Qwiic Micro OLED screen. You should see the entire screen filled with a rectangle with the \"hello\" in the middle. Try exploring the other examples in the folder and writing your own code to output on the screen.</p> Qwiic Micro OLED Connected to SparkFun Thing Plus NORA-W306 and with the Word \"hello\" Displayed"},{"location":"single_page/#example-12-lipo-fuel-gauge-max17048-with-micro-oled-display-demo","title":"Example 12 - LiPo Fuel Gauge (MAX17048) with Micro OLED Display Demo","text":"<p>Based on the examples from the LiPo Fuel Gauge and Micro OLED, we will measure a battery's capacity and display the readings on a micro OLED.</p>"},{"location":"single_page/#hardware-hookup_12","title":"Hardware Hookup","text":"<p>Connect the Qwiic micro OLED and LiPo battery to the board.</p> Fritzing Diagram Qwiic micro OLED and LiPo Battery <p>When ready, connect the board to your computer with the USB C cable.</p>"},{"location":"single_page/#installing-the-arduino-libraries","title":"Installing the Arduino Libraries","text":"<p>If you have not already, make sure to install the following libraries as explained in the previous sections. As for the WS2812, we will be using the built-in Realtek Arduino library for the WS2812.</p> <ul> <li>MAX17048</li> <li>Qwiic OLED</li> </ul>"},{"location":"single_page/#arduino-code_11","title":"Arduino Code","text":"<p>Copy and paste the following code in the Arduino IDE.</p> <pre><code>/******************************************************************************\n  Combined Simple Serial, Qwiic Micro OLED, WS2812 Example\n  Modified By: Ho Yun \"Bobby\" Chan\n  SparkFun Electronics\n  Date: July 10, 2024\n  License: MIT. See license file for more information but you can\n  basically do whatever you want with this code.\n\n  This is a combined example of Paul Clark's MAX17043 Fuel Guage\n  simple serial example, Kirk Benell's Qwiic OLED Hello example,\n  and Nathan Seidle's RTK Display Test Sketch. The example reads a\n  single cell LiPo battery's voltage and state-of-charge (SOC)\n  using the MAX1704X. The voltage, percent remaining (i.e. the\n  SOC), and alert flag are displayed as an output on the Qwiic\n  Micro OLED. A graphic of a LiPo battery's remaining charge is\n  displayed on the Qwiic Micro OLED as well. This example also uses\n  the built-in WS2812-2020 addressable LED to indicate the status\n  of the battery.\n\n  By opening the Arduino Serial Monitor (115200 baud), the example\n  will also print the gauge's voltage, state-of-charge (SOC)\n  readings, alert status to Serial.\n\n  Feel like supporting open source hardware?\n  Buy a board from SparkFun!\n\n  LiPo Fuel Gauge - MAX17043 : https://www.sparkfun.com/products/20680\n  Qwiic Micro OLED: https://www.sparkfun.com/products/14532\n\n  Distributed as-is; no warranty is given.\n******************************************************************************/\n\n#include &lt;Wire.h&gt; // Needed for I2C\n\n\n//////////LIPO FUEL GAUGE//////////\n#include &lt;SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library.h&gt; // Click here to get the library: http://librarymanager/All#SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library\n\n//SFE_MAX1704X lipo; // Defaults to the MAX17043\n\n//SFE_MAX1704X lipo(MAX1704X_MAX17043); // Create a MAX17043\n//SFE_MAX1704X lipo(MAX1704X_MAX17044); // Create a MAX17044\nSFE_MAX1704X lipo(MAX1704X_MAX17048); // Create a MAX17048\n//SFE_MAX1704X lipo(MAX1704X_MAX17049); // Create a MAX17049\n\ndouble voltage = 0; // Variable to keep track of LiPo voltage\ndouble soc = 0; // Variable to keep track of LiPo state-of-charge (SOC)\nbool alert; // Variable to keep track of whether alert has been triggered\n\n\n\n//////////QWIIC MICRO OLED//////////\n#include &lt;SparkFun_Qwiic_OLED.h&gt; //http://librarymanager/All#SparkFun_Qwiic_Graphic_OLED\n#include \"icons.h\"\n\n// The Qwiic OLED Library supports three different types of SparkFun boards. The demo uses the following\n// defines to determine which device is being used. Uncomment the device being used for this demo.\nQwiicMicroOLED myOLED;\n// QwiicTransparentOLED myOLED;\n// QwiicNarrowOLED myOLED;\n\n// Fonts\n#include &lt;res/qw_fnt_5x7.h&gt;\n//#include &lt;res/qw_fnt_8x16.h&gt;, not used\n//#include &lt;res/qw_fnt_31x48.h&gt;, not used\n//#include &lt;res/qw_fnt_7segment.h&gt;, not used\n//#include &lt;res/qw_fnt_largenum.h&gt;, not used\n\n\n// NOTE: This example uses the Realtek Arduino Core's WS2812 Library\n//////////WS2812 LED//////////\n#include \"WS2812B.h\"\n\n#define TOTAL_NUM_OF_LED 1\n#define NUM_OF_LEDS 1\n\n// There are multiple choice of SPI_MOSI pins depends on different boards. The default is SPI_MOSI/SPI1_MOSI\n// AMB21/AMB22              pin 11 /  pin21\n// AMB23                    pin 9  /  pin 4\n// BW16/BW16 Type C         pin 12\n// AW-CU488 ThingPlus       pin 1  /  pin 14\n// AMB25/AMB26              pin 17 /  pin 3\n\nWS2812B led(SPI1_PICO, NUM_OF_LEDS);\n\nvoid setup() {\n  Serial.begin(115200); // Start serial, to output debug data\n  //while (!Serial)\n  //  ; //Wait for user to open terminal\n  Serial.println(F(\"Combined MAX17048, Qwiic OLED, and Realtek WS2812 Example\"));\n\n  Wire.begin();\n\n  lipo.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial\n\n  // Set up the MAX17043 LiPo fuel gauge:\n  if (lipo.begin() == false) // Connect to the MAX17043 using the default wire port\n  {\n    Serial.println(F(\"MAX17043 not detected. Please check wiring. Freezing.\"));\n    while (1)\n      ;\n  }\n\n  // Initalize the OLED device and related graphics system\n  if (myOLED.begin() == false)\n  {\n    Serial.println(F(\"Device begin failed. Freezing...\"));\n    while (true)\n      ;\n  }\n\n  // Quick start restarts the MAX17043 in hopes of getting a more accurate\n  // guess for the SOC.\n  lipo.quickStart();\n\n  // We can set an interrupt to alert when the battery SoC gets too low.\n  // We can alert at anywhere between 1% - 32%:\n  lipo.setThreshold(20); // Set alert threshold to 20%.\n\n  //Set up WS2812B\n  led.begin();\n  //led.setPixelColor(led_position, red, green, blue);...\n  //led.setPixelColor(0, 0, 0, 0);\n  //led.show();\n  delay(1000);\n\n}\n\nvoid loop() {\n\n  // lipo.getVoltage() returns a voltage value (e.g. 3.93)\n  voltage = lipo.getVoltage();\n\n  // lipo.getSOC() returns the estimated state of charge (e.g. 79%)\n  soc = lipo.getSOC();\n\n  // lipo.getAlert() clears the alert flag\n  // Output: 0 on success, positive integer on fail.\n  lipo.clearAlert();\n  // lipo.getAlert() returns a 0 or 1 (0=alert not triggered)\n  alert = lipo.getAlert();\n\n  myOLED.erase(); //clear display\n\n  //set font type, we'll use a character size of 5x7\n  myOLED.setFont(&amp;QW_FONT_5X7);\n  //myOLED.setFont(&amp;QW_FONT_8X16); //not used\n  //myOLED.setFont(&amp;QW_FONT_31X48); //not used\n  //myOLED.setFont(&amp;QW_FONT_LARGENUM); //not used\n  //myOLED.setFont(&amp;QW_FONT_7SEGMENT); //not used\n\n  // \"Print\" Voltage\n  myOLED.setCursor(0, 0);\n  myOLED.print(voltage, 2);\n  myOLED.print(F(\"V\"));\n\n  // \"Print\" Battery %\n  myOLED.setCursor(0, 10);\n  myOLED.print(soc, 2);\n  myOLED.print(F(\"%\"));\n\n  // \"Print\" Alert Status\n  myOLED.setCursor(0, 20);\n  myOLED.print(F(\"VBAT:\")); //alert pin\n  if (alert == HIGH) {\n    myOLED.print(F(\"LOW\")); //Flag was raised, battery is low!!!\n  }\n  else {\n\n    myOLED.print(F(\"OK\")); //Battery charge is good. 8)\n  }\n\n  if (soc &gt;= 60.00) {\n    //Battery Level 60-100%\n    displayBitmap(0, 30, Battery_2_Width, Battery_2_Height, Battery_3);\n\n    //GREEN\n    led.setPixelColor(0, 0, 50, 0);\n    led.show();\n\n  }\n  else if (30.00 &lt;= soc &lt; 60.00) {\n    //Battery Level 30-60%\n    displayBitmap(0, 30, Battery_2_Width, Battery_2_Height, Battery_2);\n\n    //YELLOW\n    led.setPixelColor(0, 50, 50, 0);\n    led.show();\n  }\n  else if (10.00 &lt;= soc &lt; 30.00) {\n    //Battery Level 10%-30%\n    displayBitmap(0, 30, Battery_2_Width, Battery_2_Height, Battery_1);\n\n    //ORANGE\n    led.setPixelColor(0, 50, 25, 0);\n    led.show();\n  }\n  else {\n    //Battery Level &lt;10%\n    displayBitmap(0, 30, Battery_2_Width, Battery_2_Height, Battery_0);\n\n    //RED\n    led.setPixelColor(0, 50, 0, 0);\n    led.show();\n  }\n\n\n  // There's nothing on the screen yet - Now send the graphics to the device\n  myOLED.display();\n\n\n  // Print the variables to Serial Terminal:\n  Serial.print(F(\"Voltage: \"));\n  Serial.print(voltage);  // Print the battery voltage\n  Serial.println(\" V\");\n\n  Serial.print(F(\"Percentage: \"));\n  Serial.print(soc); // Print the battery state of charge\n  Serial.println(\" %\");\n\n  Serial.print(F(\"Alert: \"));\n  Serial.println(alert);\n  Serial.println();\n\n  delay(500);\n}\n\n\n\n//Wrapper to avoid needing to pass width/height data twice\nvoid displayBitmap(uint8_t x, uint8_t y, uint8_t imageWidth, uint8_t imageHeight, uint8_t *imageData) {\n  myOLED.bitmap(x, y, x + imageWidth, y + imageHeight, imageData, imageWidth, imageHeight);\n}\n</code></pre> <p>To keep track of the icons that we create, we are going to create a header file with the *.ino. This is useful when writing code for big projects that involve a lot of components. Click on the icon to create a new tab. We will name this icons.h.</p>  New Tab <p>Copy and paste the following code into tab.</p> <pre><code>uint8_t Battery_3 [] = {\n0xFF, 0x01, 0xFD, 0xFD, 0xFD, 0x01, 0x01, 0xFD, 0xFD, 0xFD, 0x01, 0x01, 0xFD, 0xFD, 0xFD, 0x01,\n0x0F, 0x08, 0xF8, 0x0F, 0x08, 0x0B, 0x0B, 0x0B, 0x08, 0x08, 0x0B, 0x0B, 0x0B, 0x08, 0x08, 0x0B,\n0x0B, 0x0B, 0x08, 0x0F, 0x01, 0x01,\n};\nint Battery_3_Height = 12;\nint Battery_3_Width = 19;\n\nuint8_t Battery_2 [] = {\n0xFF, 0x01, 0xFD, 0xFD, 0xFD, 0x01, 0x01, 0xFD, 0xFD, 0xFD, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n0x0F, 0x08, 0xF8, 0x0F, 0x08, 0x0B, 0x0B, 0x0B, 0x08, 0x08, 0x0B, 0x0B, 0x0B, 0x08, 0x08, 0x08,\n0x08, 0x08, 0x08, 0x0F, 0x01, 0x01,\n};\nint Battery_2_Height = 12;\nint Battery_2_Width = 19;\n\nuint8_t Battery_1 [] = {\n0xFF, 0x01, 0xFD, 0xFD, 0xFD, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n0x0F, 0x08, 0xF8, 0x0F, 0x08, 0x0B, 0x0B, 0x0B, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n0x08, 0x08, 0x08, 0x0F, 0x01, 0x01,\n};\nint Battery_1_Height = 12;\nint Battery_1_Width = 19;\n\nuint8_t Battery_0 [] = {\n0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n0x0F, 0x08, 0xF8, 0x0F, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n0x08, 0x08, 0x08, 0x0F, 0x01, 0x01,\n};\nint Battery_0_Height = 12;\nint Battery_0_Width = 19;\n</code></pre> <p>If you have not already, select your Board (in this case the SparkFun Thing Plus NORA-W306 (RTL8720DF)), and associated COM port (in this case COM13). Then hit the upload button. Disconnect the USB cable from the SparkFun Thing Plus NORA-W306 and hit the reset button on the board.</p> <p>Looking close at the display, you should see the voltage, remaining charge, the alert flag indicating if the battery is low, and a battery meter icon. These values may be different depending on how much charge the LiPo battery has available! The RGB LED color will also change to the following colors based as well: green (battery level &gt; 60%), yellow (battery level 30%-60%), orange (battery level 10%-30%), and red (battery level &lt;10%).</p> LiPo Fuel Gauge Monitoring LiPo Battery and Displaying Battery Capacity on Qwiic Micro OLED"},{"location":"single_page/#more-examples","title":"More Examples!!!","text":"<p>Of course, this only skims the surface of what the SparkFun Thing Plus - NORA-W306 can do. There are a handful of examples from the board support package that were not highlighted in this tutorial and are being ported by our friends at Realtek with the NORA-W306 module. From the menu, try opening the other examples listed for hte board: File &gt; Examples &gt; Examples for AW_CU488 Thing Plus (RTL8721DM)</p> More Arduino Examples! <p>Note</p> <p>Some of the examples listed in the menu may still be under development. Make sure to be patient as they include more support for the NORA-W306 module.</p> <p>Or try adding another Qwiic-enabled device or a breakout board to your next project!</p> Qwiic Connect System"},{"location":"single_page/#troubleshooting","title":"Troubleshooting","text":""},{"location":"single_page/#general-troubleshooting-help","title":"General Troubleshooting Help","text":"<p>Note</p> <p>  Not working as expected and need help?  </p> <p>If you need technical assistance and more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting. </p> <p>SparkFun Technical Assistance Page</p> <p>If you don't find what you need there, the SparkFun Forums are a great place to find and ask for help. If this is your first visit, you'll need to create a forum account to search product forums and post questions.</p> <p>Log Into SparkFun Forums</p>"},{"location":"single_page/#manual-upload-mode","title":"Manual Upload Mode","text":"<p>Having problems uploading code with the auto upload mode? You may see this in the output window indicating there was an error uploading.</p> <pre><code>Please enter the upload mode manually(wait 5s)\n    05\n    04\n    03\n    02\n    01\nUploading.....error: Enter Uart Download Mode\n\n    Upload Image done.\n</code></pre> <p>If you have problems uploading code when Auto Upload Mode is enabled, try uploading code manually. From the menu, select the following: Tools &gt; Auto Upload Mode: &gt; Enable. Hit the upload button in the Arduino IDE. In the debug window, you should see something similar. As the Arduino IDE starts outputting the numbers.</p> <pre><code>Please enter the upload mode manually(wait 5s)\n    05\n    04\n    03\n    02\n    01\n</code></pre> <p>Press down on the BOOT button. While holding down the BOOT button, press the RESET Button momentarily. Keep holding the BOOT button for a moment before lifting your finger off the button.</p> BOOT Button BOOT and RESET Keep Holding Down BOOT Release BOOT <p>If all goes well, you should have a successful upload with the following message.</p> <pre><code>Please enter the upload mode manually(wait 5s)\n    05\n    04\n    03\n    02\n    01\nUploading..................\n    Upload Image done.\nAll images are sent successfully!\n</code></pre> NORA-W306 Arduino Manual Upload Success <p>To execute the code, hit the reset button or power cycle the board!</p>"},{"location":"single_page/#resources","title":"Resources","text":"<p>Now that you've successfully got your SparkFun Thing Plus - NORA-W306 up and running, it's time to incorporate it into your own project! For more information, check out the resources below:</p> <ul> <li>Schematic (PDF)</li> <li>Eagle Files (ZIP)</li> <li>Board Dimensions (PNG)</li> <li>Component Datasheets<ul> <li>u-blox NORA-W306<ul> <li>Product Summary (PDF)</li> <li>Datasheet (PDF)</li> <li>Integration Manual (PDF)</li> </ul> </li> <li>XC6222 3.3V/700mA Voltage Regulator (PDF)</li> <li>MCP73831 LiPo Charger (PDF)</li> <li>MAX17048 LiPo Fuel Gauge (PDF)</li> <li>WS2812C-2020 RGB Addressable LED (PDF)</li> </ul> </li> <li>Graphical Datasheet</li> <li>Fritzing Part</li> <li>Qwiic Info Page</li> <li>Compare Thing Plus Boards</li> <li>CP210X Drivers</li> <li>Realtek: Arduino Board Support Files</li> <li>Arduino Libraries<ul> <li>MAX17048</li> <li>SdFat</li> <li>Qwiic OLED</li> </ul> </li> <li>GitHub Hardware Repo</li> <li>SFE Product Showcase</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#general-troubleshooting-help","title":"General Troubleshooting Help","text":"<p>Note</p> <p>  Not working as expected and need help?  </p> <p>If you need technical assistance and more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting. </p> <p>SparkFun Technical Assistance Page</p> <p>If you don't find what you need there, the SparkFun Forums are a great place to find and ask for help. If this is your first visit, you'll need to create a forum account to search product forums and post questions.</p> <p>Log Into SparkFun Forums</p>"},{"location":"troubleshooting/#manual-upload-mode","title":"Manual Upload Mode","text":"<p>Having problems uploading code with the auto upload mode? You may see this in the output window indicating there was an error uploading.</p> <pre><code>Please enter the upload mode manually(wait 5s)\n    05\n    04\n    03\n    02\n    01\nUploading.....error: Enter Uart Download Mode\n\n    Upload Image done.\n</code></pre> <p>If you have problems uploading code when Auto Upload Mode is enabled, try uploading code manually. From the menu, select the following: Tools &gt; Auto Upload Mode: &gt; Enable. Hit the upload button in the Arduino IDE. In the debug window, you should see something similar. As the Arduino IDE starts outputting the numbers.</p> <pre><code>Please enter the upload mode manually(wait 5s)\n    05\n    04\n    03\n    02\n    01\n</code></pre> <p>Press down on the BOOT button. While holding down the BOOT button, press the RESET Button momentarily. Keep holding the BOOT button for a moment before lifting your finger off the button.</p> BOOT Button BOOT and RESET Keep Holding Down BOOT Release BOOT <p>If all goes well, you should have a successful upload with the following message.</p> <pre><code>Please enter the upload mode manually(wait 5s)\n    05\n    04\n    03\n    02\n    01\nUploading..................\n    Upload Image done.\nAll images are sent successfully!\n</code></pre> NORA-W306 Arduino Manual Upload Success <p>To execute the code, hit the reset button or power cycle the board!</p>"},{"location":"github/contribute/","title":"Contribute: Help Fix our Mistake!","text":"<p>Spot something wrong? Feel free to contribute our open-source design and documentation. </p>"},{"location":"github/contribute/#improve-our-documentation","title":"Improve our Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>These pages are contained in the <code>docs</code> folder of the SparkFun Thing Plus NORA-W306 repository.</li> </ul>"},{"location":"github/contribute/#submit-a-correction","title":"Submit a Correction","text":"<ol> <li>Fork this repo</li> <li>Add your corrections or improvements to the markdown file</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvements to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/contribute/#improve-our-hardware-design","title":"Improve our Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun Thing Plus NORA-W306 repository.</li> </ul>"},{"location":"github/contribute/#submit-a-design-improvement","title":"Submit a Design Improvement","text":"<ol> <li>Fork this repo</li> <li>Add your design improvements</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvements, if they are within our board design standards and meet our product design requirements, we will flag these changes for our next board revision. (Please note, that even if your suggestion is accepted, these changes may not be immediate. We may have to cycle through our current product inventory first.)</li> </ul> </li> </ol>"},{"location":"github/contribute/#contributors","title":"Contributors","text":"<p>Let's provided some recognition to the contributors for this project!</p> <p> </p>"},{"location":"github/file_issue/","title":"Did we make a mistake?","text":"<p>Spot something wrong? Please let us know. </p> <p>Attention</p> <p>This is not where customers should seek assistance on a product. If you require technical assistance or have questions about a product that is not working as expected, please head over to the SparkFun Technical Assistance page for some initial troubleshooting.  SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, you'll need a Forum Account to search product forums and post questions.</p>"},{"location":"github/file_issue/#discrepancies-in-the-documentation","title":"Discrepancies in the Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>The documentation files for these pages are contained in the <code>docs</code> folder of the SparkFun Thing Plus NORA-W306 repository.</li> </ul>"},{"location":"github/file_issue/#spot-something-wrong","title":"Spot something wrong?","text":"<p>If a section of the documentation is incorrect, please open an issue and let us know.</p>"},{"location":"github/file_issue/#do-you-have-a-suggested-correction","title":"Do you have a suggested correction?","text":"<ol> <li>With a GitHub account, fork this repo</li> <li>Add your correction(s) or improvement(s) to the markdown file(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvement(s) to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/file_issue/#problems-in-the-hardware-design","title":"Problems in the Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun Thing Plus NORA-W306 repository.</li> </ul>"},{"location":"github/file_issue/#does-something-not-make-sense","title":"Does something not make sense?","text":"<p>If part of the design is confusing, please open an issue and let us know.</p>"},{"location":"github/file_issue/#did-we-forget-to-include-an-important-function-of-the-board","title":"Did we forget to include an important function of the board?","text":"<ul> <li>Please keep in mind that we may intentionally exclude certain functions of the board to meet our product design requirements. (For example, our Qwiic Micro boards are intended to fit on a small board layout and only use I<sup>2</sup>C communication; therefore, we may not have the SPI and interrupt pins available for users.)</li> <li>If part of the board's functionality is missing, please open an issue and file a feature request.</li> </ul>"},{"location":"github/file_issue/#do-you-wish-to-contribute-directly-to-improving-the-board-design","title":"Do you wish to contribute directly to improving the board design?","text":"<ol> <li>With a GitHub account, Fork this repo</li> <li>Add your design improvement(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s), if they are within our board design standards and meet our product design requirements, we will flag these changes for our next board revision. (Please note, that even if your suggestion is accepted, these changes may not be immediate. We may have to cycle through our current product inventory first.)</li> </ul> </li> </ol>"},{"location":"javascript/","title":"javascript directory","text":"<p>This folder should contain the files for the custom javascript that is enabled in the product documentation</p>"}]}